[
  {
    "path": ".editorconfig",
    "content": "# Remove the line below if you want to inherit .editorconfig settings from higher directories\r\nroot = true\r\n\r\n# C# files\r\n[*.cs]\r\n\r\n#### Core EditorConfig Options ####\r\n\r\n# Indentation and spacing\r\nindent_size = 4\r\nindent_style = space\r\ntab_width = 4\r\n\r\n# New line preferences\r\nend_of_line = crlf\r\ninsert_final_newline = false\r\n\r\n#### .NET Code Actions ####\r\n\r\n# Type members\r\ndotnet_hide_advanced_members = false\r\ndotnet_member_insertion_location = with_other_members_of_the_same_kind\r\ndotnet_property_generation_behavior = prefer_throwing_properties\r\n\r\n# Symbol search\r\ndotnet_search_reference_assemblies = true\r\n\r\n#### .NET Coding Conventions ####\r\n\r\n# Organize usings\r\ndotnet_separate_import_directive_groups = false\r\ndotnet_sort_system_directives_first = false\r\nfile_header_template = unset\r\n\r\n# this. and Me. preferences\r\ndotnet_style_qualification_for_event = false\r\ndotnet_style_qualification_for_field = false\r\ndotnet_style_qualification_for_method = false\r\ndotnet_style_qualification_for_property = false\r\n\r\n# Language keywords vs BCL types preferences\r\ndotnet_style_predefined_type_for_locals_parameters_members = true\r\ndotnet_style_predefined_type_for_member_access = true\r\n\r\n# Parentheses preferences\r\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity\r\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity\r\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary\r\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity\r\n\r\n# Modifier preferences\r\ndotnet_style_require_accessibility_modifiers = for_non_interface_members\r\n\r\n# Expression-level preferences\r\ndotnet_prefer_system_hash_code = true\r\ndotnet_style_coalesce_expression = true\r\ndotnet_style_collection_initializer = true\r\ndotnet_style_explicit_tuple_names = true\r\ndotnet_style_namespace_match_folder = true\r\ndotnet_style_null_propagation = true\r\ndotnet_style_object_initializer = true\r\ndotnet_style_operator_placement_when_wrapping = beginning_of_line\r\ndotnet_style_prefer_auto_properties = true\r\ndotnet_style_prefer_collection_expression = when_types_loosely_match\r\ndotnet_style_prefer_compound_assignment = true\r\ndotnet_style_prefer_conditional_expression_over_assignment = true\r\ndotnet_style_prefer_conditional_expression_over_return = true\r\ndotnet_style_prefer_foreach_explicit_cast_in_source = when_strongly_typed\r\ndotnet_style_prefer_inferred_anonymous_type_member_names = true\r\ndotnet_style_prefer_inferred_tuple_names = true\r\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true\r\ndotnet_style_prefer_simplified_boolean_expressions = true\r\ndotnet_style_prefer_simplified_interpolation = true\r\n\r\n# Field preferences\r\ndotnet_style_readonly_field = true\r\n\r\n# Parameter preferences\r\ndotnet_code_quality_unused_parameters = all\r\n\r\n# Suppression preferences\r\ndotnet_remove_unnecessary_suppression_exclusions = none\r\n\r\n# New line preferences\r\ndotnet_style_allow_multiple_blank_lines_experimental = true\r\ndotnet_style_allow_statement_immediately_after_block_experimental = true\r\n\r\n#### C# Coding Conventions ####\r\n\r\n# var preferences\r\ncsharp_style_var_elsewhere = false:silent\r\ncsharp_style_var_for_built_in_types = false:silent\r\ncsharp_style_var_when_type_is_apparent = false:silent\r\n\r\n# Expression-bodied members\r\ncsharp_style_expression_bodied_accessors = true:silent\r\ncsharp_style_expression_bodied_constructors = false:silent\r\ncsharp_style_expression_bodied_indexers = true:silent\r\ncsharp_style_expression_bodied_lambdas = true:silent\r\ncsharp_style_expression_bodied_local_functions = false:silent\r\ncsharp_style_expression_bodied_methods = false:silent\r\ncsharp_style_expression_bodied_operators = false:silent\r\ncsharp_style_expression_bodied_properties = true:silent\r\n\r\n# Pattern matching preferences\r\ncsharp_style_pattern_matching_over_as_with_null_check = true:suggestion\r\ncsharp_style_pattern_matching_over_is_with_cast_check = true:suggestion\r\ncsharp_style_prefer_extended_property_pattern = true:suggestion\r\ncsharp_style_prefer_not_pattern = true:suggestion\r\ncsharp_style_prefer_pattern_matching = true:silent\r\ncsharp_style_prefer_switch_expression = true:suggestion\r\n\r\n# Null-checking preferences\r\ncsharp_style_conditional_delegate_call = true:suggestion\r\n\r\n# Modifier preferences\r\ncsharp_prefer_static_anonymous_function = true:suggestion\r\ncsharp_prefer_static_local_function = true:suggestion\r\ncsharp_preferred_modifier_order = public,private,protected,internal,file,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,required,volatile,async\r\ncsharp_style_prefer_readonly_struct = true:suggestion\r\ncsharp_style_prefer_readonly_struct_member = true:suggestion\r\n\r\n# Code-block preferences\r\ncsharp_prefer_braces = true:warning\r\ncsharp_prefer_simple_using_statement = true:suggestion\r\ncsharp_prefer_system_threading_lock = true:suggestion\r\ncsharp_style_namespace_declarations = file_scoped:error\r\ncsharp_style_prefer_method_group_conversion = true:silent\r\ncsharp_style_prefer_primary_constructors = true:silent\r\ncsharp_style_prefer_top_level_statements = true:silent\r\n\r\n# Expression-level preferences\r\ncsharp_prefer_simple_default_expression = true:suggestion\r\ncsharp_style_deconstructed_variable_declaration = true:suggestion\r\ncsharp_style_implicit_object_creation_when_type_is_apparent = true:suggestion\r\ncsharp_style_inlined_variable_declaration = true:suggestion\r\ncsharp_style_prefer_index_operator = true:suggestion\r\ncsharp_style_prefer_local_over_anonymous_function = true:suggestion\r\ncsharp_style_prefer_null_check_over_type_check = true:suggestion\r\ncsharp_style_prefer_range_operator = true:suggestion\r\ncsharp_style_prefer_tuple_swap = true:suggestion\r\ncsharp_style_prefer_unbound_generic_type_in_nameof = true:suggestion\r\ncsharp_style_prefer_utf8_string_literals = true:suggestion\r\ncsharp_style_throw_expression = true:suggestion\r\ncsharp_style_unused_value_assignment_preference = discard_variable:suggestion\r\ncsharp_style_unused_value_expression_statement_preference = discard_variable:silent\r\n\r\n# \u0027using\u0027 directive preferences\r\ncsharp_using_directive_placement = outside_namespace:warning\r\n\r\n# New line preferences\r\ncsharp_style_allow_blank_line_after_colon_in_constructor_initializer_experimental = true:silent\r\ncsharp_style_allow_blank_line_after_token_in_arrow_expression_clause_experimental = true:silent\r\ncsharp_style_allow_blank_line_after_token_in_conditional_expression_experimental = true:silent\r\ncsharp_style_allow_blank_lines_between_consecutive_braces_experimental = true:silent\r\ncsharp_style_allow_embedded_statements_on_same_line_experimental = true:silent\r\n\r\n#### C# Formatting Rules ####\r\n\r\n# New line preferences\r\ncsharp_new_line_before_catch = true\r\ncsharp_new_line_before_else = true\r\ncsharp_new_line_before_finally = true\r\ncsharp_new_line_before_members_in_anonymous_types = true\r\ncsharp_new_line_before_members_in_object_initializers = true\r\ncsharp_new_line_before_open_brace = all\r\ncsharp_new_line_between_query_expression_clauses = true\r\n\r\n# Indentation preferences\r\ncsharp_indent_block_contents = true\r\ncsharp_indent_braces = false\r\ncsharp_indent_case_contents = true\r\ncsharp_indent_case_contents_when_block = true\r\ncsharp_indent_labels = one_less_than_current\r\ncsharp_indent_switch_labels = true\r\n\r\n# Space preferences\r\ncsharp_space_after_cast = false\r\ncsharp_space_after_colon_in_inheritance_clause = true\r\ncsharp_space_after_comma = true\r\ncsharp_space_after_dot = false\r\ncsharp_space_after_keywords_in_control_flow_statements = true\r\ncsharp_space_after_semicolon_in_for_statement = true\r\ncsharp_space_around_binary_operators = before_and_after\r\ncsharp_space_around_declaration_statements = false\r\ncsharp_space_before_colon_in_inheritance_clause = true\r\ncsharp_space_before_comma = false\r\ncsharp_space_before_dot = false\r\ncsharp_space_before_open_square_brackets = false\r\ncsharp_space_before_semicolon_in_for_statement = false\r\ncsharp_space_between_empty_square_brackets = false\r\ncsharp_space_between_method_call_empty_parameter_list_parentheses = false\r\ncsharp_space_between_method_call_name_and_opening_parenthesis = false\r\ncsharp_space_between_method_call_parameter_list_parentheses = false\r\ncsharp_space_between_method_declaration_empty_parameter_list_parentheses = false\r\ncsharp_space_between_method_declaration_name_and_open_parenthesis = false\r\ncsharp_space_between_method_declaration_parameter_list_parentheses = false\r\ncsharp_space_between_parentheses = false\r\ncsharp_space_between_square_brackets = false\r\n\r\n# Wrapping preferences\r\ncsharp_preserve_single_line_blocks = true\r\ncsharp_preserve_single_line_statements = true\r\n\r\n#### Naming styles ####\r\n\r\n# Naming rules\r\n\r\ndotnet_naming_rule.interface_should_be_begins_with_i.severity = error\r\ndotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface\r\ndotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i\r\n\r\ndotnet_naming_rule.types_should_be_pascal_case.severity = warning\r\ndotnet_naming_rule.types_should_be_pascal_case.symbols = types\r\ndotnet_naming_rule.types_should_be_pascal_case.style = pascal_case\r\n\r\ndotnet_naming_rule.non_field_members_should_be_pascal_case.severity = warning\r\ndotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members\r\ndotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case\r\n\r\n# Symbol specifications\r\n\r\ndotnet_naming_symbols.interface.applicable_kinds = interface\r\ndotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\r\ndotnet_naming_symbols.interface.required_modifiers = \r\n\r\ndotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum\r\ndotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\r\ndotnet_naming_symbols.types.required_modifiers = \r\n\r\ndotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method\r\ndotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected\r\ndotnet_naming_symbols.non_field_members.required_modifiers = \r\n\r\n# Naming styles\r\n\r\ndotnet_naming_style.pascal_case.required_prefix = \r\ndotnet_naming_style.pascal_case.required_suffix = \r\ndotnet_naming_style.pascal_case.word_separator = \r\ndotnet_naming_style.pascal_case.capitalization = pascal_case\r\n\r\ndotnet_naming_style.begins_with_i.required_prefix = I\r\ndotnet_naming_style.begins_with_i.required_suffix = \r\ndotnet_naming_style.begins_with_i.word_separator = \r\ndotnet_naming_style.begins_with_i.capitalization = pascal_case\r\ncsharp_style_prefer_implicitly_typed_lambda_expression = true:suggestion\r\ndotnet_diagnostic.CA1309.severity = suggestion\r\ndotnet_diagnostic.CA2016.severity = warning\r\n\r\n[*.{cs,vb}]\r\ndotnet_style_operator_placement_when_wrapping = beginning_of_line\r\ntab_width = 4\r\nindent_size = 4\r\nend_of_line = crlf\r\ndotnet_style_coalesce_expression = true:suggestion\r\ndotnet_style_null_propagation = true:suggestion\r\ndotnet_style_prefer_is_null_check_over_reference_equality_method = true:warning\r\ndotnet_style_prefer_auto_properties = true:warning\r\ndotnet_style_object_initializer = true:suggestion\r\ndotnet_style_collection_initializer = true:suggestion\r\ndotnet_style_prefer_simplified_boolean_expressions = true:suggestion\r\ndotnet_style_prefer_conditional_expression_over_assignment = true:silent\r\ndotnet_style_prefer_conditional_expression_over_return = true:silent\r\ndotnet_style_explicit_tuple_names = true:suggestion\r\ndotnet_style_prefer_inferred_tuple_names = true:suggestion\r\ndotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion\r\ndotnet_style_prefer_compound_assignment = true:suggestion\r\ndotnet_style_prefer_simplified_interpolation = true:suggestion\r\ndotnet_style_prefer_collection_expression = when_types_loosely_match:suggestion\r\ndotnet_style_namespace_match_folder = true:error\r\ndotnet_style_readonly_field = true:warning\r\ndotnet_style_predefined_type_for_member_access = true:warning\r\ndotnet_style_predefined_type_for_locals_parameters_members = true:warning\r\ndotnet_style_require_accessibility_modifiers = for_non_interface_members:silent\r\ndotnet_style_allow_multiple_blank_lines_experimental = true:silent\r\ndotnet_style_allow_statement_immediately_after_block_experimental = true:silent\r\ndotnet_code_quality_unused_parameters = all:suggestion\r\ndotnet_style_parentheses_in_arithmetic_binary_operators = always_for_clarity:silent\r\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity:silent\r\ndotnet_style_parentheses_in_relational_binary_operators = always_for_clarity:silent\r\ndotnet_style_parentheses_in_other_operators = never_if_unnecessary:silent\r\ndotnet_style_qualification_for_field = false:silent\r\ndotnet_style_qualification_for_property = false:silent\r\ndotnet_style_qualification_for_method = false:silent\r\ndotnet_style_qualification_for_event = false:silent\r\ndotnet_diagnostic.CA1068.severity = warning\r\ndotnet_diagnostic.CA1069.severity = error\r\ndotnet_diagnostic.CA1310.severity = warning\r\ndotnet_diagnostic.CA1501.severity = error\r\ndotnet_diagnostic.CA1852.severity = warning\r\n[*.vb]\r\ndotnet_diagnostic.CA1047.severity = warning"
  },
  {
    "path": "Scratchpad.sln",
    "content": "\r\nMicrosoft Visual Studio Solution File, Format Version 12.00\r\n# Visual Studio Version 17\r\nVisualStudioVersion = 17.12.35527.113\r\nMinimumVisualStudioVersion = 10.0.40219.1\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Scratchpad.ConsoleApp\u0022, \u0022Scratchpad.ConsoleApp\\Scratchpad.ConsoleApp.csproj\u0022, \u0022{9C369474-8D27-A67D-2CA6-4B390981866A}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Scratchpad.Lib\u0022, \u0022Scratchpad.Lib\\Scratchpad.Lib.csproj\u0022, \u0022{BBFB979D-6A5E-3E00-EAED-936D938C409F}\u0022\r\nEndProject\r\nProject(\u0022{2150E333-8FDC-42A3-9474-1A3956D46DE8}\u0022) = \u0022Solution Items\u0022, \u0022Solution Items\u0022, \u0022{8EC462FD-D22E-90A8-E5CE-7E832BA40C5D}\u0022\r\n\tProjectSection(SolutionItems) = preProject\r\n\t\t.editorconfig = .editorconfig\r\n\tEndProjectSection\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Scratchpad.Ollama\u0022, \u0022Scratchpad.Ollama\\Scratchpad.Ollama.csproj\u0022, \u0022{1FFD2D49-84DA-26E4-267E-E897476450BD}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022VSExtensionDemo\u0022, \u0022Scratchpad.VSExtensionDemo\\VSExtensionDemo.csproj\u0022, \u0022{E09D6A93-6B9F-4051-B2CF-7A8F49607985}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022VSUtilsExtension\u0022, \u0022Scratchpad.VSUtilsExtension\\VSUtilsExtension.csproj\u0022, \u0022{397DB9EC-5788-484C-9496-66BA0741B7FC}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022RemoteClipboard\u0022, \u0022RemoteClipboard\\RemoteClipboard.csproj\u0022, \u0022{2C296C6F-EB32-45CA-B7C4-52819AD92387}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022ProjectPacker\u0022, \u0022ProjectPacker\\ProjectPacker.csproj\u0022, \u0022{00254135-168B-4DA7-9993-F4D6449DCFD9}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022LogGrep\u0022, \u0022LogGrep\\LogGrep.csproj\u0022, \u0022{74502B5F-2E14-4980-B416-66865E90D55B}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022LogSearch.ConsoleApp\u0022, \u0022LogSearch\\LogSearch.ConsoleApp\\LogSearch.ConsoleApp.csproj\u0022, \u0022{E54625F1-F599-06C7-305A-3AAFD32072B5}\u0022\r\nEndProject\r\nProject(\u0022{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u0022) = \u0022Vaerktojer.Prompt\u0022, \u0022..\\..\\..\\Vaerktojer.Prompt\\Vaerktojer.Prompt\\Vaerktojer.Prompt.csproj\u0022, \u0022{294959AF-A123-9E61-7A8F-4FB0531BF212}\u0022\r\nEndProject\r\nGlobal\r\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\r\n\t\tDebug|Any CPU = Debug|Any CPU\r\n\t\tRelease|Any CPU = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\r\n\t\t{9C369474-8D27-A67D-2CA6-4B390981866A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{9C369474-8D27-A67D-2CA6-4B390981866A}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{9C369474-8D27-A67D-2CA6-4B390981866A}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{9C369474-8D27-A67D-2CA6-4B390981866A}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{BBFB979D-6A5E-3E00-EAED-936D938C409F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{BBFB979D-6A5E-3E00-EAED-936D938C409F}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{BBFB979D-6A5E-3E00-EAED-936D938C409F}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{BBFB979D-6A5E-3E00-EAED-936D938C409F}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{1FFD2D49-84DA-26E4-267E-E897476450BD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{1FFD2D49-84DA-26E4-267E-E897476450BD}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{1FFD2D49-84DA-26E4-267E-E897476450BD}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{1FFD2D49-84DA-26E4-267E-E897476450BD}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{E09D6A93-6B9F-4051-B2CF-7A8F49607985}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{E09D6A93-6B9F-4051-B2CF-7A8F49607985}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{E09D6A93-6B9F-4051-B2CF-7A8F49607985}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{E09D6A93-6B9F-4051-B2CF-7A8F49607985}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{397DB9EC-5788-484C-9496-66BA0741B7FC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{397DB9EC-5788-484C-9496-66BA0741B7FC}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{397DB9EC-5788-484C-9496-66BA0741B7FC}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{397DB9EC-5788-484C-9496-66BA0741B7FC}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{2C296C6F-EB32-45CA-B7C4-52819AD92387}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{2C296C6F-EB32-45CA-B7C4-52819AD92387}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{2C296C6F-EB32-45CA-B7C4-52819AD92387}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{2C296C6F-EB32-45CA-B7C4-52819AD92387}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{00254135-168B-4DA7-9993-F4D6449DCFD9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{00254135-168B-4DA7-9993-F4D6449DCFD9}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{00254135-168B-4DA7-9993-F4D6449DCFD9}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{00254135-168B-4DA7-9993-F4D6449DCFD9}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{74502B5F-2E14-4980-B416-66865E90D55B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{74502B5F-2E14-4980-B416-66865E90D55B}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{74502B5F-2E14-4980-B416-66865E90D55B}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{74502B5F-2E14-4980-B416-66865E90D55B}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{E54625F1-F599-06C7-305A-3AAFD32072B5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{E54625F1-F599-06C7-305A-3AAFD32072B5}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{E54625F1-F599-06C7-305A-3AAFD32072B5}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{E54625F1-F599-06C7-305A-3AAFD32072B5}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\t\t{294959AF-A123-9E61-7A8F-4FB0531BF212}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\r\n\t\t{294959AF-A123-9E61-7A8F-4FB0531BF212}.Debug|Any CPU.Build.0 = Debug|Any CPU\r\n\t\t{294959AF-A123-9E61-7A8F-4FB0531BF212}.Release|Any CPU.ActiveCfg = Release|Any CPU\r\n\t\t{294959AF-A123-9E61-7A8F-4FB0531BF212}.Release|Any CPU.Build.0 = Release|Any CPU\r\n\tEndGlobalSection\r\n\tGlobalSection(SolutionProperties) = preSolution\r\n\t\tHideSolutionNode = FALSE\r\n\tEndGlobalSection\r\n\tGlobalSection(ExtensibilityGlobals) = postSolution\r\n\t\tSolutionGuid = {941EC9BC-0511-4BA2-A34F-C72C1C55DCCA}\r\n\tEndGlobalSection\r\nEndGlobal\r\n"
  },
  {
    "path": "Scratchpad.VSUtilsExtension\\source.extension.vsixmanifest",
    "content": "\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003CPackageManifest Version=\u00222.0.0\u0022 xmlns=\u0022http://schemas.microsoft.com/developer/vsx-schema/2011\u0022 xmlns:d=\u0022http://schemas.microsoft.com/developer/vsx-schema-design/2011\u0022\u003E\r\n  \u003CMetadata\u003E\r\n    \u003CIdentity Id=\u0022VSUtilsExtension.7ecbac0c-05f0-4357-acf1-8fdb8995341f\u0022 Version=\u00221.0\u0022 Language=\u0022en-US\u0022 Publisher=\u0022Company\u0022 /\u003E\r\n    \u003CDisplayName\u003EVSUtilsExtension\u003C/DisplayName\u003E\r\n    \u003CDescription\u003EEmpty VSIX Project.\u003C/Description\u003E\r\n  \u003C/Metadata\u003E\r\n  \u003CInstallation\u003E\r\n    \u003CInstallationTarget Id=\u0022Microsoft.VisualStudio.Community\u0022 Version=\u0022[17.0, 18.0)\u0022\u003E\r\n      \u003CProductArchitecture\u003Eamd64\u003C/ProductArchitecture\u003E\r\n    \u003C/InstallationTarget\u003E\r\n  \u003C/Installation\u003E\r\n  \u003CDependencies\u003E\r\n    \u003CDependency Id=\u0022Microsoft.Framework.NDP\u0022 DisplayName=\u0022Microsoft .NET Framework\u0022 d:Source=\u0022Manual\u0022 Version=\u0022[4.5,)\u0022 /\u003E\r\n  \u003C/Dependencies\u003E\r\n  \u003CPrerequisites\u003E\r\n    \u003CPrerequisite Id=\u0022Microsoft.VisualStudio.Component.CoreEditor\u0022 Version=\u0022[17.0,18.0)\u0022 DisplayName=\u0022Visual Studio core editor\u0022 /\u003E\r\n  \u003C/Prerequisites\u003E\r\n  \u003CAssets\u003E\r\n    \u003CAsset Type=\u0022Microsoft.VisualStudio.VsPackage\u0022 d:Source=\u0022Project\u0022 d:ProjectName=\u0022%CurrentProject%\u0022 Path=\u0022|%CurrentProject%;PkgdefProjectOutputGroup|\u0022 /\u003E\r\n  \u003C/Assets\u003E\r\n\u003C/PackageManifest\u003E\r\n"
  },
  {
    "path": "Scratchpad.VSUtilsExtension\\ViewInTFSCommand.cs",
    "content": "using System;\r\nusing System.ComponentModel.Design;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing EnvDTE80;\r\nusing Microsoft.VisualStudio.Shell;\r\nusing Microsoft.VisualStudio.Shell.Interop;\r\nusing Task = System.Threading.Tasks.Task;\r\n\r\nnamespace VSUtilsExtension\r\n{\r\n    internal sealed class ViewInTFSCommand\r\n    {\r\n        public const int CommandId = 0x0101;\r\n\r\n        public static readonly Guid CommandSet = new Guid(\u00227bb3cbdf-a82a-46ff-a7a8-603a994041e5\u0022);\r\n\r\n        private readonly AsyncPackage package;\r\n\r\n        private ViewInTFSCommand(AsyncPackage package, OleMenuCommandService commandService)\r\n        {\r\n            this.package = package ?? throw new ArgumentNullException(nameof(package));\r\n            commandService =\r\n                commandService ?? throw new ArgumentNullException(nameof(commandService));\r\n\r\n            var menuCommandID = new CommandID(CommandSet, CommandId);\r\n            var menuItem = new MenuCommand(this.Execute, menuCommandID);\r\n            commandService.AddCommand(menuItem);\r\n        }\r\n\r\n        public static ViewInTFSCommand Instance { get; private set; }\r\n\r\n        private Microsoft.VisualStudio.Shell.IAsyncServiceProvider ServiceProvider\r\n        {\r\n            get { return this.package; }\r\n        }\r\n\r\n        public static async Task InitializeAsync(AsyncPackage package)\r\n        {\r\n            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(package.DisposalToken);\r\n\r\n            OleMenuCommandService commandService =\r\n                await package.GetServiceAsync(typeof(IMenuCommandService)) as OleMenuCommandService;\r\n            Instance = new ViewInTFSCommand(package, commandService);\r\n        }\r\n\r\n        private void Execute(object sender, EventArgs e)\r\n        {\r\n            ThreadHelper.ThrowIfNotOnUIThread();\r\n\r\n            try\r\n            {\r\n                var dte = Package.GetGlobalService(typeof(SDTE)) as DTE2;\r\n\r\n                var filePath = dte.ActiveDocument?.FullName;\r\n\r\n                if (string.IsNullOrWhiteSpace(filePath))\r\n                {\r\n                    return;\r\n                }\r\n\r\n                var workingDirectory = Path.GetDirectoryName(filePath);\r\n\r\n                var remoteUrl = RunGitCommandAndReadOutput(\r\n                    workingDirectory,\r\n                    \u0022remote get-url origin\u0022\r\n                );\r\n                var baseRepositoryPath = RunGitCommandAndReadOutput(\r\n                    workingDirectory,\r\n                    \u0022rev-parse --show-toplevel\u0022\r\n                );\r\n\r\n                if (string.IsNullOrEmpty(remoteUrl) || string.IsNullOrEmpty(baseRepositoryPath))\r\n                {\r\n                    ShowErrorDialog(\r\n                        \u0022Error\u0022,\r\n                        \u0022File is not part of a git repository or remote is not available.\u0022\r\n                    );\r\n                    return;\r\n                }\r\n\r\n                // Would be cool to use alongside \u0026version=GB{currentBranch} but takes too much time, bad ux\r\n                // var currentBranch = RunGitCommand(workingDirectory, \u0022rev-parse --abbrev-ref HEAD\u0022).StandardOutput.ReadToEnd().Trim();\r\n                // var branchExistsInRemote = RunGitCommand(workingDirectory, $\u0022ls-remote --heads origin {currentBranch}\u0022).StandardOutput.ReadToEnd().Trim();\r\n\r\n                var baseRepositoryDirectory = Path.GetFullPath(baseRepositoryPath);\r\n\r\n                var remainingPath = filePath.TrimPrefix(baseRepositoryDirectory).Replace(\u0027\\\\\u0027, \u0027/\u0027);\r\n\r\n                var url = $\u0022{remoteUrl}?path={remainingPath}\u0022;\r\n\r\n                OpenInBrowser(url);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ShowErrorDialog(\u0022An Error Occurred\u0022, ex.Message);\r\n            }\r\n        }\r\n\r\n        private void ShowErrorDialog(string title, string message)\r\n        {\r\n            VsShellUtilities.ShowMessageBox(\r\n                package,\r\n                message,\r\n                title,\r\n                OLEMSGICON.OLEMSGICON_CRITICAL,\r\n                OLEMSGBUTTON.OLEMSGBUTTON_OK,\r\n                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST\r\n            );\r\n        }\r\n\r\n        private Process OpenInBrowser(string url)\r\n        {\r\n            return Process.Start(\u0022explorer.exe\u0022, $\u0022\\\u0022{url}\\\u0022\u0022);\r\n        }\r\n\r\n        private string RunGitCommandAndReadOutput(string workingDirectory, string arguments)\r\n        {\r\n            var process = Process.Start(\r\n                new ProcessStartInfo\r\n                {\r\n                    FileName = \u0022git\u0022,\r\n                    Arguments = arguments,\r\n                    UseShellExecute = false,\r\n                    RedirectStandardOutput = true,\r\n                    RedirectStandardError = true,\r\n                    CreateNoWindow = true,\r\n                    WorkingDirectory = workingDirectory,\r\n                }\r\n            );\r\n\r\n            using (process)\r\n            {\r\n                return process.StandardOutput.ReadToEnd().Trim();\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.VSUtilsExtension\\VSUtilsExtension.csproj",
    "content": "\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003CProject\r\n  ToolsVersion=\u002215.0\u0022\r\n  DefaultTargets=\u0022Build\u0022\r\n  xmlns=\u0022http://schemas.microsoft.com/developer/msbuild/2003\u0022\r\n\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CMinimumVisualStudioVersion\u003E17.0\u003C/MinimumVisualStudioVersion\u003E\r\n    \u003CVSToolsPath Condition=\u0022\u0027$(VSToolsPath)\u0027 == \u0027\u0027\u0022\r\n      \u003E$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\u003C/VSToolsPath\r\n    \u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CImport\r\n    Project=\u0022$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\u0022\r\n    Condition=\u0022Exists(\u0027$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\u0027)\u0022\r\n  /\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CConfiguration Condition=\u0022 \u0027$(Configuration)\u0027 == \u0027\u0027 \u0022\u003EDebug\u003C/Configuration\u003E\r\n    \u003CPlatform Condition=\u0022 \u0027$(Platform)\u0027 == \u0027\u0027 \u0022\u003EAnyCPU\u003C/Platform\u003E\r\n    \u003CSchemaVersion\u003E2.0\u003C/SchemaVersion\u003E\r\n    \u003CProjectTypeGuids\u003E{82b43b9b-a64c-4715-b499-d71e9ca2bd60};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u003C/ProjectTypeGuids\u003E\r\n    \u003CProjectGuid\u003E{397DB9EC-5788-484C-9496-66BA0741B7FC}\u003C/ProjectGuid\u003E\r\n    \u003COutputType\u003ELibrary\u003C/OutputType\u003E\r\n    \u003CAppDesignerFolder\u003EProperties\u003C/AppDesignerFolder\u003E\r\n    \u003CRootNamespace\u003EVSUtilsExtension\u003C/RootNamespace\u003E\r\n    \u003CAssemblyName\u003EVSUtilsExtension\u003C/AssemblyName\u003E\r\n    \u003CTargetFrameworkVersion\u003Ev4.7.2\u003C/TargetFrameworkVersion\u003E\r\n    \u003CGeneratePkgDefFile\u003Etrue\u003C/GeneratePkgDefFile\u003E\r\n    \u003CUseCodebase\u003Etrue\u003C/UseCodebase\u003E\r\n    \u003CIncludeAssemblyInVSIXContainer\u003Etrue\u003C/IncludeAssemblyInVSIXContainer\u003E\r\n    \u003CIncludeDebugSymbolsInVSIXContainer\u003Efalse\u003C/IncludeDebugSymbolsInVSIXContainer\u003E\r\n    \u003CIncludeDebugSymbolsInLocalVSIXDeployment\u003Efalse\u003C/IncludeDebugSymbolsInLocalVSIXDeployment\u003E\r\n    \u003CCopyBuildOutputToOutputDirectory\u003Etrue\u003C/CopyBuildOutputToOutputDirectory\u003E\r\n    \u003CCopyOutputSymbolsToOutputDirectory\u003Etrue\u003C/CopyOutputSymbolsToOutputDirectory\u003E\r\n    \u003CStartAction\u003EProgram\u003C/StartAction\u003E\r\n    \u003CStartProgram Condition=\u0022\u0027$(DevEnvDir)\u0027 != \u0027\u0027\u0022\u003E$(DevEnvDir)devenv.exe\u003C/StartProgram\u003E\r\n    \u003CStartArguments\u003E/rootsuffix Exp\u003C/StartArguments\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CPropertyGroup Condition=\u0022 \u0027$(Configuration)|$(Platform)\u0027 == \u0027Debug|AnyCPU\u0027 \u0022\u003E\r\n    \u003CDebugSymbols\u003Etrue\u003C/DebugSymbols\u003E\r\n    \u003CDebugType\u003Efull\u003C/DebugType\u003E\r\n    \u003COptimize\u003Efalse\u003C/Optimize\u003E\r\n    \u003COutputPath\u003Ebin\\Debug\\\u003C/OutputPath\u003E\r\n    \u003CDefineConstants\u003EDEBUG;TRACE\u003C/DefineConstants\u003E\r\n    \u003CErrorReport\u003Eprompt\u003C/ErrorReport\u003E\r\n    \u003CWarningLevel\u003E4\u003C/WarningLevel\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CPropertyGroup Condition=\u0022 \u0027$(Configuration)|$(Platform)\u0027 == \u0027Release|AnyCPU\u0027 \u0022\u003E\r\n    \u003CDebugType\u003Epdbonly\u003C/DebugType\u003E\r\n    \u003COptimize\u003Etrue\u003C/Optimize\u003E\r\n    \u003COutputPath\u003Ebin\\Release\\\u003C/OutputPath\u003E\r\n    \u003CDefineConstants\u003ETRACE\u003C/DefineConstants\u003E\r\n    \u003CErrorReport\u003Eprompt\u003C/ErrorReport\u003E\r\n    \u003CWarningLevel\u003E4\u003C/WarningLevel\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CCompile Include=\u0022Properties\\AssemblyInfo.cs\u0022 /\u003E\r\n    \u003CCompile Include=\u0022ViewInTFSCommand.cs\u0022 /\u003E\r\n    \u003CCompile Include=\u0022VSUtilsExtensionPackage.cs\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CNone Include=\u0022source.extension.vsixmanifest\u0022\u003E\r\n      \u003CSubType\u003EDesigner\u003C/SubType\u003E\r\n    \u003C/None\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CReference Include=\u0022System\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CReference Include=\u0022Microsoft.CSharp\u0022 /\u003E\r\n    \u003CReference Include=\u0022System\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Data\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Design\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Drawing\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Windows.Forms\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Xml\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.VisualStudio.SDK\u0022\r\n      Version=\u002217.0.32112.339\u0022\r\n      ExcludeAssets=\u0022runtime\u0022\r\n      NoWarn=\u0022NU1604\u0022\r\n    /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.VSSDK.BuildTools\u0022 Version=\u002217.13.2126\u0022 NoWarn=\u0022NU1604\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CVSCTCompile Include=\u0022VSUtilsExtensionPackage.vsct\u0022\u003E\r\n      \u003CResourceName\u003EMenus.ctmenu\u003C/ResourceName\u003E\r\n    \u003C/VSCTCompile\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CImport Project=\u0022$(MSBuildToolsPath)\\Microsoft.CSharp.targets\u0022 /\u003E\r\n  \u003CImport\r\n    Project=\u0022$(VSToolsPath)\\VSSDK\\Microsoft.VsSDK.targets\u0022\r\n    Condition=\u0022\u0027$(VSToolsPath)\u0027 != \u0027\u0027\u0022\r\n  /\u003E\r\n  \u003C!-- To modify your build process, add your task inside one of the targets below and uncomment it.\r\n       Other similar extension points exist, see Microsoft.Common.targets.\r\n  \u003CTarget Name=\u0022BeforeBuild\u0022\u003E\r\n  \u003C/Target\u003E\r\n  \u003CTarget Name=\u0022AfterBuild\u0022\u003E\r\n  \u003C/Target\u003E\r\n  --\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Scratchpad.VSUtilsExtension\\VSUtilsExtensionPackage.cs",
    "content": "using System;\r\nusing System.Runtime.InteropServices;\r\nusing System.Threading;\r\nusing Microsoft.VisualStudio.Shell;\r\nusing Task = System.Threading.Tasks.Task;\r\n\r\nnamespace VSUtilsExtension\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// This is the class that implements the package exposed by this assembly.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// \u003Cpara\u003E\r\n    /// The minimum requirement for a class to be considered a valid package for Visual Studio\r\n    /// is to implement the IVsPackage interface and register itself with the shell.\r\n    /// This package uses the helper classes defined inside the Managed Package Framework (MPF)\r\n    /// to do it: it derives from the Package class that provides the implementation of the\r\n    /// IVsPackage interface and uses the registration attributes defined in the framework to\r\n    /// register itself and its components with the shell. These attributes tell the pkgdef creation\r\n    /// utility what data to put into .pkgdef file.\r\n    /// \u003C/para\u003E\r\n    /// \u003Cpara\u003E\r\n    /// To get loaded into VS, the package must be referred by \u0026lt;Asset Type=\u0022Microsoft.VisualStudio.VsPackage\u0022 ...\u0026gt; in .vsixmanifest file.\r\n    /// \u003C/para\u003E\r\n    /// \u003C/remarks\u003E\r\n    [PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]\r\n    [Guid(VSUtilsExtensionPackage.PackageGuidString)]\r\n    public sealed class VSUtilsExtensionPackage : AsyncPackage\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// VSUtilsExtensionPackage GUID string.\r\n        /// \u003C/summary\u003E\r\n        public const string PackageGuidString = \u0022275bba8c-9473-457d-aedc-3975b190f20f\u0022;\r\n\r\n        #region Package Members\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initialization of the package; this method is called right after the package is sited, so this is the place\r\n        /// where you can put all the initialization code that rely on services provided by VisualStudio.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022cancellationToken\u0022\u003EA cancellation token to monitor for initialization cancellation, which can occur when VS is shutting down.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022progress\u0022\u003EA provider for progress updates.\u003C/param\u003E\r\n        /// \u003Creturns\u003EA task representing the async work of package initialization, or an already completed task if there is none. Do not return null from this method.\u003C/returns\u003E\r\n        protected override async Task InitializeAsync(\r\n            CancellationToken cancellationToken,\r\n            IProgress\u003CServiceProgressData\u003E progress\r\n        )\r\n        {\r\n            // When initialized asynchronously, the current thread may be a background thread at this point.\r\n            // Do any initialization that requires the UI thread after switching to the UI thread.\r\n            await this.JoinableTaskFactory.SwitchToMainThreadAsync(cancellationToken);\r\n            await ViewInTFSCommand.InitializeAsync(this);\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.VSUtilsExtension\\VSUtilsExtensionPackage.vsct",
    "content": "\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003CCommandTable xmlns=\u0022http://schemas.microsoft.com/VisualStudio/2005-10-18/CommandTable\u0022 xmlns:xs=\u0022http://www.w3.org/2001/XMLSchema\u0022\u003E\r\n  \u003CExtern href=\u0022stdidcmd.h\u0022 /\u003E\r\n  \u003CExtern href=\u0022vsshlids.h\u0022 /\u003E\r\n\r\n  \u003CCommands package=\u0022guidVSUtilsExtensionPackage\u0022\u003E\r\n    \u003CGroups\u003E\r\n      \u003CGroup guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 priority=\u00220x0000\u0022\u003E\r\n        \u003CParent guid=\u0022guidSHLMainMenu\u0022 id=\u0022IDM_VS_CTXT_CODEWIN\u0022 /\u003E\r\n      \u003C/Group\u003E\r\n    \u003C/Groups\u003E\r\n    \u003CButtons\u003E\r\n      \u003CButton guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022ViewInFileExplorerCommandId\u0022 priority=\u00220x0100\u0022 type=\u0022Button\u0022\u003E\r\n        \u003CParent guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n        \u003CStrings\u003E\r\n          \u003CButtonText\u003EView In File Explorer\u003C/ButtonText\u003E\r\n        \u003C/Strings\u003E\r\n      \u003C/Button\u003E\r\n\t\t\r\n      \u003CButton guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022OpenWithVSCodeCommandId\u0022 priority=\u00220x0101\u0022 type=\u0022Button\u0022\u003E\r\n        \u003CParent guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n        \u003CStrings\u003E\r\n          \u003CButtonText\u003EOpen With VSCode\u003C/ButtonText\u003E\r\n        \u003C/Strings\u003E\r\n      \u003C/Button\u003E\r\n\r\n      \u003CButton guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022OpenInTerminalCommandId\u0022 priority=\u00220x0102\u0022 type=\u0022Button\u0022\u003E\r\n        \u003CParent guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n        \u003CStrings\u003E\r\n          \u003CButtonText\u003EOpen In Terminal\u003C/ButtonText\u003E\r\n        \u003C/Strings\u003E\r\n      \u003C/Button\u003E\r\n\r\n      \u003CButton guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022ViewInTFSCommandId\u0022 priority=\u00220x0103\u0022 type=\u0022Button\u0022\u003E\r\n        \u003CParent guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n        \u003CStrings\u003E\r\n          \u003CButtonText\u003EView In TFS\u003C/ButtonText\u003E\r\n        \u003C/Strings\u003E\r\n      \u003C/Button\u003E\r\n\r\n      \u003CButton guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022ValidateConfigCommandId\u0022 priority=\u00220x0104\u0022 type=\u0022Button\u0022\u003E\r\n        \u003CParent guid=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n        \u003CStrings\u003E\r\n          \u003CButtonText\u003EValidate Config\u003C/ButtonText\u003E\r\n        \u003C/Strings\u003E\r\n      \u003C/Button\u003E\r\n    \u003C/Buttons\u003E\r\n\r\n  \u003C/Commands\u003E\r\n\r\n  \u003CSymbols\u003E\r\n    \u003C!-- This is the package guid. --\u003E\r\n    \u003CGuidSymbol name=\u0022guidVSUtilsExtensionPackage\u0022 value=\u0022{275bba8c-9473-457d-aedc-3975b190f20f}\u0022 /\u003E\r\n\r\n    \u003C!-- This is the guid used to group the menu commands together --\u003E\r\n    \u003CGuidSymbol name=\u0022guidVSUtilsExtensionPackageCmdSet\u0022 value=\u0022{7bb3cbdf-a82a-46ff-a7a8-603a994041e5}\u0022\u003E\r\n      \u003CIDSymbol name=\u0022EditorContextMenuGroup\u0022 value=\u00220x1020\u0022 /\u003E\r\n      \u003CIDSymbol name=\u0022ViewInFileExplorerCommandId\u0022 value=\u00220x0100\u0022 /\u003E\r\n\t  \u003CIDSymbol name=\u0022ViewInTFSCommandId\u0022 value=\u00220x0101\u0022  /\u003E\r\n\t  \u003CIDSymbol name=\u0022OpenWithVSCodeCommandId\u0022 value=\u00220x0102\u0022  /\u003E\r\n\t  \u003CIDSymbol name=\u0022OpenInTerminalCommandId\u0022 value=\u00220x0103\u0022  /\u003E\r\n      \u003CIDSymbol name=\u0022ValidateConfigCommandId\u0022 value=\u00220x0104\u0022  /\u003E\r\n    \u003C/GuidSymbol\u003E\r\n\r\n  \u003C/Symbols\u003E\r\n\u003C/CommandTable\u003E\r\n"
  },
  {
    "path": "Scratchpad.VSUtilsExtension\\Properties\\AssemblyInfo.cs",
    "content": "using System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\n\r\n// General Information about an assembly is controlled through the following\r\n// set of attributes. Change these attribute values to modify the information\r\n// associated with an assembly.\r\n[assembly: AssemblyTitle(\u0022VSUtilsExtension\u0022)]\r\n[assembly: AssemblyDescription(\u0022\u0022)]\r\n[assembly: AssemblyConfiguration(\u0022\u0022)]\r\n[assembly: AssemblyCompany(\u0022\u0022)]\r\n[assembly: AssemblyProduct(\u0022VSUtilsExtension\u0022)]\r\n[assembly: AssemblyCopyright(\u0022\u0022)]\r\n[assembly: AssemblyTrademark(\u0022\u0022)]\r\n[assembly: AssemblyCulture(\u0022\u0022)]\r\n\r\n// Setting ComVisible to false makes the types in this assembly not visible\r\n// to COM components.  If you need to access a type in this assembly from\r\n// COM, set the ComVisible attribute to true on that type.\r\n[assembly: ComVisible(false)]\r\n\r\n// Version information for an assembly consists of the following four values:\r\n//\r\n//      Major Version\r\n//      Minor Version\r\n//      Build Number\r\n//      Revision\r\n//\r\n// You can specify all the values or you can default the Build and Revision Numbers\r\n// by using the \u0027*\u0027 as shown below:\r\n// [assembly: AssemblyVersion(\u00221.0.*\u0022)]\r\n[assembly: AssemblyVersion(\u00221.0.0.0\u0022)]\r\n[assembly: AssemblyFileVersion(\u00221.0.0.0\u0022)]\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\OpenFileInExplorerCommand.cs",
    "content": "using System;\r\nusing System.ComponentModel.Design;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing EnvDTE80;\r\nusing Microsoft.VisualStudio.Shell;\r\nusing Microsoft.VisualStudio.Shell.Interop;\r\nusing Task = System.Threading.Tasks.Task;\r\n\r\nnamespace VSExtensionDemo\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Command handler\r\n    /// \u003C/summary\u003E\r\n    internal sealed class OpenFileInExplorerCommand\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Command ID.\r\n        /// \u003C/summary\u003E\r\n        public const int CommandId = 0x0100;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Command menu group (command set GUID).\r\n        /// \u003C/summary\u003E\r\n        public static readonly Guid CommandSet = new Guid(\u00221ba84305-8cf4-438f-90b7-557a332aceca\u0022);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// VS Package that provides this command, not null.\r\n        /// \u003C/summary\u003E\r\n        private readonly AsyncPackage package;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initializes a new instance of the \u003Csee cref=\u0022OpenFileInExplorerCommand\u0022/\u003E class.\r\n        /// Adds our command handlers for menu (commands must exist in the command table file)\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022package\u0022\u003EOwner package, not null.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022commandService\u0022\u003ECommand service to add command to, not null.\u003C/param\u003E\r\n        private OpenFileInExplorerCommand(\r\n            AsyncPackage package,\r\n            OleMenuCommandService commandService\r\n        )\r\n        {\r\n            this.package = package ?? throw new ArgumentNullException(nameof(package));\r\n            commandService =\r\n                commandService ?? throw new ArgumentNullException(nameof(commandService));\r\n\r\n            var menuCommandID = new CommandID(CommandSet, CommandId);\r\n            var menuItem = new MenuCommand(this.Execute, menuCommandID);\r\n            commandService.AddCommand(menuItem);\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Gets the instance of the command.\r\n        /// \u003C/summary\u003E\r\n        public static OpenFileInExplorerCommand Instance { get; private set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Gets the service provider from the owner package.\r\n        /// \u003C/summary\u003E\r\n        private Microsoft.VisualStudio.Shell.IAsyncServiceProvider ServiceProvider\r\n        {\r\n            get { return this.package; }\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initializes the singleton instance of the command.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022package\u0022\u003EOwner package, not null.\u003C/param\u003E\r\n        public static async Task InitializeAsync(AsyncPackage package)\r\n        {\r\n            // Switch to the main thread - the call to AddCommand in Command1\u0027s constructor requires\r\n            // the UI thread.\r\n            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(package.DisposalToken);\r\n\r\n            OleMenuCommandService commandService =\r\n                await package.GetServiceAsync(typeof(IMenuCommandService)) as OleMenuCommandService;\r\n            Instance = new OpenFileInExplorerCommand(package, commandService);\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// This function is the callback used to execute the command when the menu item is clicked.\r\n        /// See the constructor to see how the menu item is associated with this function using\r\n        /// OleMenuCommandService service and MenuCommand class.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022sender\u0022\u003EEvent sender.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022e\u0022\u003EEvent args.\u003C/param\u003E\r\n        private void Execute(object sender, EventArgs e)\r\n        {\r\n            ThreadHelper.ThrowIfNotOnUIThread();\r\n\r\n            var dte = Package.GetGlobalService(typeof(SDTE)) as DTE2;\r\n\r\n            VsShellUtilities.ShowMessageBox(\r\n                package,\r\n                \u0022Message\u0022,\r\n                \u0022My title\u0022,\r\n                OLEMSGICON.OLEMSGICON_INFO,\r\n                OLEMSGBUTTON.OLEMSGBUTTON_OK,\r\n                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST\r\n            );\r\n\r\n            var filePath = dte.ActiveDocument?.FullName;\r\n            if (string.IsNullOrWhiteSpace(filePath))\r\n            {\r\n                return;\r\n            }\r\n\r\n            Process.Start(\u0022explorer.exe\u0022, $\u0022/select,\\\u0022{filePath}\\\u0022\u0022);\r\n\r\n            var workingDirectory = Path.GetDirectoryName(filePath);\r\n\r\n            var startInfo = new ProcessStartInfo\r\n            {\r\n                FileName = \u0022git\u0022,\r\n                Arguments = \u0022status\u0022,\r\n                UseShellExecute = false,\r\n                RedirectStandardOutput = true,\r\n                CreateNoWindow = true,\r\n                WorkingDirectory = workingDirectory,\r\n            };\r\n\r\n            var process = Process.Start(startInfo);\r\n            var remoteUrl = process.StandardOutput.ReadToEnd().Trim();\r\n\r\n            Console.WriteLine(remoteUrl);\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\OpenInScoreTFSCommand.cs",
    "content": "using System;\r\nusing System.ComponentModel.Design;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing EnvDTE80;\r\nusing Microsoft.VisualStudio.Shell;\r\nusing Microsoft.VisualStudio.Shell.Interop;\r\nusing Task = System.Threading.Tasks.Task;\r\n\r\nnamespace VSExtensionDemo\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Command handler\r\n    /// \u003C/summary\u003E\r\n    internal sealed class OpenInScoreTFSCommand\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Command ID.\r\n        /// \u003C/summary\u003E\r\n        public const int CommandId = 0x0101;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Command menu group (command set GUID).\r\n        /// \u003C/summary\u003E\r\n        public static readonly Guid CommandSet = new Guid(\u00221ba84305-8cf4-438f-90b7-557a332aceca\u0022);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// VS Package that provides this command, not null.\r\n        /// \u003C/summary\u003E\r\n        private readonly AsyncPackage package;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initializes a new instance of the \u003Csee cref=\u0022OpenInScoreTFSCommand\u0022/\u003E class.\r\n        /// Adds our command handlers for menu (commands must exist in the command table file)\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022package\u0022\u003EOwner package, not null.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022commandService\u0022\u003ECommand service to add command to, not null.\u003C/param\u003E\r\n        private OpenInScoreTFSCommand(AsyncPackage package, OleMenuCommandService commandService)\r\n        {\r\n            this.package = package ?? throw new ArgumentNullException(nameof(package));\r\n            commandService =\r\n                commandService ?? throw new ArgumentNullException(nameof(commandService));\r\n\r\n            var menuCommandID = new CommandID(CommandSet, CommandId);\r\n            var menuItem = new MenuCommand(this.Execute, menuCommandID);\r\n            commandService.AddCommand(menuItem);\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Gets the instance of the command.\r\n        /// \u003C/summary\u003E\r\n        public static OpenInScoreTFSCommand Instance { get; private set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Gets the service provider from the owner package.\r\n        /// \u003C/summary\u003E\r\n        private Microsoft.VisualStudio.Shell.IAsyncServiceProvider ServiceProvider\r\n        {\r\n            get { return this.package; }\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initializes the singleton instance of the command.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022package\u0022\u003EOwner package, not null.\u003C/param\u003E\r\n        public static async Task InitializeAsync(AsyncPackage package)\r\n        {\r\n            // Switch to the main thread - the call to AddCommand in OpenInScoreTFSCommand\u0027s constructor requires\r\n            // the UI thread.\r\n            await ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(package.DisposalToken);\r\n\r\n            OleMenuCommandService commandService =\r\n                await package.GetServiceAsync(typeof(IMenuCommandService)) as OleMenuCommandService;\r\n            Instance = new OpenInScoreTFSCommand(package, commandService);\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// This function is the callback used to execute the command when the menu item is clicked.\r\n        /// See the constructor to see how the menu item is associated with this function using\r\n        /// OleMenuCommandService service and MenuCommand class.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022sender\u0022\u003EEvent sender.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022e\u0022\u003EEvent args.\u003C/param\u003E\r\n        private void Execute(object sender, EventArgs e)\r\n        {\r\n            ThreadHelper.ThrowIfNotOnUIThread();\r\n            var dte = Package.GetGlobalService(typeof(SDTE)) as DTE2;\r\n\r\n            var filePath = dte.ActiveDocument?.FullName;\r\n            if (string.IsNullOrWhiteSpace(filePath))\r\n            {\r\n                return;\r\n            }\r\n\r\n            var workingDirectory = Path.GetDirectoryName(filePath);\r\n\r\n            var startInfo = new ProcessStartInfo\r\n            {\r\n                FileName = \u0022git\u0022,\r\n                Arguments = \u0022status\u0022,\r\n                UseShellExecute = false,\r\n                RedirectStandardOutput = true,\r\n                CreateNoWindow = true,\r\n                WorkingDirectory = workingDirectory,\r\n            };\r\n\r\n            var process = Process.Start(startInfo);\r\n            var remoteUrl = process.StandardOutput.ReadToEnd().Trim();\r\n\r\n            VsShellUtilities.ShowMessageBox(\r\n                package,\r\n                remoteUrl,\r\n                \u0022My title\u0022,\r\n                OLEMSGICON.OLEMSGICON_INFO,\r\n                OLEMSGBUTTON.OLEMSGBUTTON_OK,\r\n                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST\r\n            );\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\source.extension.vsixmanifest",
    "content": "\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003CPackageManifest Version=\u00222.0.0\u0022 xmlns=\u0022http://schemas.microsoft.com/developer/vsx-schema/2011\u0022 xmlns:d=\u0022http://schemas.microsoft.com/developer/vsx-schema-design/2011\u0022\u003E\r\n    \u003CMetadata\u003E\r\n        \u003CIdentity Id=\u0022VSExtensionDemo.beb70a2c-f7e7-46cb-b112-150879142b48\u0022 Version=\u00221.0\u0022 Language=\u0022en-US\u0022 Publisher=\u0022akifisitan\u0022 /\u003E\r\n        \u003CDisplayName\u003EVSExtensionDemo\u003C/DisplayName\u003E\r\n        \u003CDescription xml:space=\u0022preserve\u0022\u003EVs extension demo\u003C/Description\u003E\r\n    \u003C/Metadata\u003E\r\n    \u003CInstallation\u003E\r\n        \u003CInstallationTarget Id=\u0022Microsoft.VisualStudio.Community\u0022 Version=\u0022[17.0, 18.0)\u0022\u003E\r\n            \u003CProductArchitecture\u003Eamd64\u003C/ProductArchitecture\u003E\r\n        \u003C/InstallationTarget\u003E\r\n    \u003C/Installation\u003E\r\n    \u003CDependencies\u003E\r\n        \u003CDependency Id=\u0022Microsoft.Framework.NDP\u0022 DisplayName=\u0022Microsoft .NET Framework\u0022 d:Source=\u0022Manual\u0022 Version=\u0022[4.5,)\u0022 /\u003E\r\n    \u003C/Dependencies\u003E\r\n    \u003CPrerequisites\u003E\r\n        \u003CPrerequisite Id=\u0022Microsoft.VisualStudio.Component.CoreEditor\u0022 Version=\u0022[17.0,18.0)\u0022 DisplayName=\u0022Visual Studio core editor\u0022 /\u003E\r\n    \u003C/Prerequisites\u003E\r\n    \u003CAssets\u003E\r\n        \u003CAsset Type=\u0022Microsoft.VisualStudio.VsPackage\u0022 d:Source=\u0022Project\u0022 d:ProjectName=\u0022%CurrentProject%\u0022 Path=\u0022|%CurrentProject%;PkgdefProjectOutputGroup|\u0022 /\u003E\r\n    \u003C/Assets\u003E\r\n\u003C/PackageManifest\u003E\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\Utils.cs",
    "content": "using Microsoft.VisualStudio.Shell;\r\nusing Microsoft.VisualStudio.Shell.Interop;\r\n\r\nnamespace VSExtensionDemo\r\n{\r\n    internal static class Utils\r\n    {\r\n        private static void ShowErrorDialog(AsyncPackage package, string title, string message)\r\n        {\r\n            VsShellUtilities.ShowMessageBox(\r\n                package,\r\n                message,\r\n                title,\r\n                OLEMSGICON.OLEMSGICON_CRITICAL,\r\n                OLEMSGBUTTON.OLEMSGBUTTON_OK,\r\n                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST\r\n            );\r\n        }\r\n\r\n        private static void ShowDialog(AsyncPackage package, string title, string message)\r\n        {\r\n            VsShellUtilities.ShowMessageBox(\r\n                package,\r\n                message,\r\n                title,\r\n                OLEMSGICON.OLEMSGICON_INFO,\r\n                OLEMSGBUTTON.OLEMSGBUTTON_OK,\r\n                OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST\r\n            );\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\VSExtensionDemo.csproj",
    "content": "\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003CProject\r\n  ToolsVersion=\u002215.0\u0022\r\n  DefaultTargets=\u0022Build\u0022\r\n  xmlns=\u0022http://schemas.microsoft.com/developer/msbuild/2003\u0022\r\n\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CMinimumVisualStudioVersion\u003E17.0\u003C/MinimumVisualStudioVersion\u003E\r\n    \u003CVSToolsPath Condition=\u0022\u0027$(VSToolsPath)\u0027 == \u0027\u0027\u0022\r\n      \u003E$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\u003C/VSToolsPath\r\n    \u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CImport\r\n    Project=\u0022$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\u0022\r\n    Condition=\u0022Exists(\u0027$(MSBuildExtensionsPath)\\$(MSBuildToolsVersion)\\Microsoft.Common.props\u0027)\u0022\r\n  /\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CConfiguration Condition=\u0022 \u0027$(Configuration)\u0027 == \u0027\u0027 \u0022\u003EDebug\u003C/Configuration\u003E\r\n    \u003CPlatform Condition=\u0022 \u0027$(Platform)\u0027 == \u0027\u0027 \u0022\u003EAnyCPU\u003C/Platform\u003E\r\n    \u003CSchemaVersion\u003E2.0\u003C/SchemaVersion\u003E\r\n    \u003CProjectTypeGuids\u003E{82b43b9b-a64c-4715-b499-d71e9ca2bd60};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}\u003C/ProjectTypeGuids\u003E\r\n    \u003CProjectGuid\u003E{E09D6A93-6B9F-4051-B2CF-7A8F49607985}\u003C/ProjectGuid\u003E\r\n    \u003COutputType\u003ELibrary\u003C/OutputType\u003E\r\n    \u003CAppDesignerFolder\u003EProperties\u003C/AppDesignerFolder\u003E\r\n    \u003CRootNamespace\u003EVSExtensionDemo\u003C/RootNamespace\u003E\r\n    \u003CAssemblyName\u003EVSExtensionDemo\u003C/AssemblyName\u003E\r\n    \u003CTargetFrameworkVersion\u003Ev4.7.2\u003C/TargetFrameworkVersion\u003E\r\n    \u003CGeneratePkgDefFile\u003Etrue\u003C/GeneratePkgDefFile\u003E\r\n    \u003CUseCodebase\u003Etrue\u003C/UseCodebase\u003E\r\n    \u003CIncludeAssemblyInVSIXContainer\u003Etrue\u003C/IncludeAssemblyInVSIXContainer\u003E\r\n    \u003CIncludeDebugSymbolsInVSIXContainer\u003Efalse\u003C/IncludeDebugSymbolsInVSIXContainer\u003E\r\n    \u003CIncludeDebugSymbolsInLocalVSIXDeployment\u003Efalse\u003C/IncludeDebugSymbolsInLocalVSIXDeployment\u003E\r\n    \u003CCopyBuildOutputToOutputDirectory\u003Etrue\u003C/CopyBuildOutputToOutputDirectory\u003E\r\n    \u003CCopyOutputSymbolsToOutputDirectory\u003Etrue\u003C/CopyOutputSymbolsToOutputDirectory\u003E\r\n    \u003CStartAction\u003EProgram\u003C/StartAction\u003E\r\n    \u003CStartProgram Condition=\u0022\u0027$(DevEnvDir)\u0027 != \u0027\u0027\u0022\u003E$(DevEnvDir)devenv.exe\u003C/StartProgram\u003E\r\n    \u003CStartArguments\u003E/rootsuffix Exp\u003C/StartArguments\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CPropertyGroup Condition=\u0022 \u0027$(Configuration)|$(Platform)\u0027 == \u0027Debug|AnyCPU\u0027 \u0022\u003E\r\n    \u003CDebugSymbols\u003Etrue\u003C/DebugSymbols\u003E\r\n    \u003CDebugType\u003Efull\u003C/DebugType\u003E\r\n    \u003COptimize\u003Efalse\u003C/Optimize\u003E\r\n    \u003COutputPath\u003Ebin\\Debug\\\u003C/OutputPath\u003E\r\n    \u003CDefineConstants\u003EDEBUG;TRACE\u003C/DefineConstants\u003E\r\n    \u003CErrorReport\u003Eprompt\u003C/ErrorReport\u003E\r\n    \u003CWarningLevel\u003E4\u003C/WarningLevel\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CPropertyGroup Condition=\u0022 \u0027$(Configuration)|$(Platform)\u0027 == \u0027Release|AnyCPU\u0027 \u0022\u003E\r\n    \u003CDebugType\u003Epdbonly\u003C/DebugType\u003E\r\n    \u003COptimize\u003Etrue\u003C/Optimize\u003E\r\n    \u003COutputPath\u003Ebin\\Release\\\u003C/OutputPath\u003E\r\n    \u003CDefineConstants\u003ETRACE\u003C/DefineConstants\u003E\r\n    \u003CErrorReport\u003Eprompt\u003C/ErrorReport\u003E\r\n    \u003CWarningLevel\u003E4\u003C/WarningLevel\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CCompile Include=\u0022OpenFileInExplorerCommand.cs\u0022 /\u003E\r\n    \u003CCompile Include=\u0022OpenInScoreTFSCommand.cs\u0022 /\u003E\r\n    \u003CCompile Include=\u0022Properties\\AssemblyInfo.cs\u0022 /\u003E\r\n    \u003CCompile Include=\u0022Utils.cs\u0022 /\u003E\r\n    \u003CCompile Include=\u0022VSExtensionDemoPackage.cs\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CNone Include=\u0022source.extension.vsixmanifest\u0022\u003E\r\n      \u003CSubType\u003EDesigner\u003C/SubType\u003E\r\n    \u003C/None\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CReference Include=\u0022Microsoft.CSharp\u0022 /\u003E\r\n    \u003CReference Include=\u0022System\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Data\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Design\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Drawing\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Windows.Forms\u0022 /\u003E\r\n    \u003CReference Include=\u0022System.Xml\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.VisualStudio.SDK\u0022\r\n      Version=\u002217.0.32112.339\u0022\r\n      ExcludeAssets=\u0022runtime\u0022\r\n    /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.VSSDK.BuildTools\u0022 Version=\u002217.12.2069\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CVSCTCompile Include=\u0022VSExtensionDemoPackage.vsct\u0022\u003E\r\n      \u003CResourceName\u003EMenus.ctmenu\u003C/ResourceName\u003E\r\n    \u003C/VSCTCompile\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CContent Include=\u0022Resources\\OpenInFileExplorerCommand.png\u0022 /\u003E\r\n    \u003CContent Include=\u0022Resources\\OpenInScoreTFSCommand.png\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CImport Project=\u0022$(MSBuildToolsPath)\\Microsoft.CSharp.targets\u0022 /\u003E\r\n  \u003CImport\r\n    Project=\u0022$(VSToolsPath)\\VSSDK\\Microsoft.VsSDK.targets\u0022\r\n    Condition=\u0022\u0027$(VSToolsPath)\u0027 != \u0027\u0027\u0022\r\n  /\u003E\r\n  \u003C!-- To modify your build process, add your task inside one of the targets below and uncomment it. \r\n       Other similar extension points exist, see Microsoft.Common.targets.\r\n  \u003CTarget Name=\u0022BeforeBuild\u0022\u003E\r\n  \u003C/Target\u003E\r\n  \u003CTarget Name=\u0022AfterBuild\u0022\u003E\r\n  \u003C/Target\u003E\r\n  --\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\VSExtensionDemoPackage.cs",
    "content": "using System;\r\nusing System.Runtime.InteropServices;\r\nusing System.Threading;\r\nusing Microsoft.VisualStudio.Shell;\r\nusing Task = System.Threading.Tasks.Task;\r\n\r\nnamespace VSExtensionDemo\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// This is the class that implements the package exposed by this assembly.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// \u003Cpara\u003E\r\n    /// The minimum requirement for a class to be considered a valid package for Visual Studio\r\n    /// is to implement the IVsPackage interface and register itself with the shell.\r\n    /// This package uses the helper classes defined inside the Managed Package Framework (MPF)\r\n    /// to do it: it derives from the Package class that provides the implementation of the\r\n    /// IVsPackage interface and uses the registration attributes defined in the framework to\r\n    /// register itself and its components with the shell. These attributes tell the pkgdef creation\r\n    /// utility what data to put into .pkgdef file.\r\n    /// \u003C/para\u003E\r\n    /// \u003Cpara\u003E\r\n    /// To get loaded into VS, the package must be referred by \u0026lt;Asset Type=\u0022Microsoft.VisualStudio.VsPackage\u0022 ...\u0026gt; in .vsixmanifest file.\r\n    /// \u003C/para\u003E\r\n    /// \u003C/remarks\u003E\r\n    [PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]\r\n    [Guid(VSExtensionDemoPackage.PackageGuidString)]\r\n    [ProvideMenuResource(\u0022Menus.ctmenu\u0022, 1)]\r\n    public sealed class VSExtensionDemoPackage : AsyncPackage\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// VSExtensionDemoPackage GUID string.\r\n        /// \u003C/summary\u003E\r\n        public const string PackageGuidString = \u0022463871e1-83b4-4c3e-953b-af3b4061e284\u0022;\r\n\r\n        #region Package Members\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initialization of the package; this method is called right after the package is sited, so this is the place\r\n        /// where you can put all the initialization code that rely on services provided by VisualStudio.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022cancellationToken\u0022\u003EA cancellation token to monitor for initialization cancellation, which can occur when VS is shutting down.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022progress\u0022\u003EA provider for progress updates.\u003C/param\u003E\r\n        /// \u003Creturns\u003EA task representing the async work of package initialization, or an already completed task if there is none. Do not return null from this method.\u003C/returns\u003E\r\n        protected override async Task InitializeAsync(\r\n            CancellationToken cancellationToken,\r\n            IProgress\u003CServiceProgressData\u003E progress\r\n        )\r\n        {\r\n            // When initialized asynchronously, the current thread may be a background thread at this point.\r\n            // Do any initialization that requires the UI thread after switching to the UI thread.\r\n            await this.JoinableTaskFactory.SwitchToMainThreadAsync(cancellationToken);\r\n            await OpenFileInExplorerCommand.InitializeAsync(this);\r\n            await OpenInScoreTFSCommand.InitializeAsync(this);\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\VSExtensionDemoPackage.vsct",
    "content": "\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003CCommandTable xmlns=\u0022http://schemas.microsoft.com/VisualStudio/2005-10-18/CommandTable\u0022 xmlns:xs=\u0022http://www.w3.org/2001/XMLSchema\u0022\u003E\r\n\r\n\t\u003CExtern href=\u0022stdidcmd.h\u0022/\u003E\r\n\t\u003CExtern href=\u0022vsshlids.h\u0022/\u003E\r\n\r\n\t\u003CCommands package=\u0022guidVSExtensionDemoPackage\u0022\u003E\r\n\t\t\u003CGroups\u003E\r\n\t\t\t\u003C!-- Editor context menu --\u003E\r\n\t\t\t\u003CGroup guid=\u0022guidVSExtensionDemoPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 priority=\u00220x0000\u0022\u003E\r\n\t\t\t\t\u003CParent guid=\u0022guidSHLMainMenu\u0022 id=\u0022IDM_VS_CTXT_CODEWIN\u0022 /\u003E\r\n\t\t\t\u003C/Group\u003E\r\n\t\t\u003C/Groups\u003E\r\n\r\n\t\t\u003CButtons\u003E\r\n\t\t\t\r\n\t\t\t\u003C!-- Button for \u0022Open in File Explorer\u0022 --\u003E\r\n\t\t\t\u003CButton guid=\u0022guidVSExtensionDemoPackageCmdSet\u0022 id=\u0022OpenInExplorerCommandId\u0022 priority=\u00220x0200\u0022 type=\u0022Button\u0022\u003E\r\n\t\t\t\t\u003CParent guid=\u0022guidVSExtensionDemoPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n\t\t\t\t\u003CIcon guid=\u0022guidImages\u0022 id=\u0022bmpPic1\u0022 /\u003E\r\n\t\t\t\t\u003CStrings\u003E\r\n\t\t\t\t\t\u003CButtonText\u003EOpen in File Explorer\u003C/ButtonText\u003E\r\n\t\t\t\t\u003C/Strings\u003E\r\n\t\t\t\u003C/Button\u003E\r\n\t\t\t\r\n\t\t\t\u003C!-- Button for \u0022Open in ScoreTFS\u0022 --\u003E\r\n\t\t\t\u003CButton guid=\u0022guidVSExtensionDemoPackageCmdSet\u0022 id=\u0022OpenInScoreTFSCommandId\u0022 priority=\u00220x0200\u0022 type=\u0022Button\u0022\u003E\r\n\t\t\t\t\u003CParent guid=\u0022guidVSExtensionDemoPackageCmdSet\u0022 id=\u0022EditorContextMenuGroup\u0022 /\u003E\r\n\t\t\t\t\u003CIcon guid=\u0022guidImages\u0022 id=\u0022bmpPic2\u0022 /\u003E\r\n\t\t\t\t\u003CStrings\u003E\r\n\t\t\t\t\t\u003CButtonText\u003EOpen in ScoreTFS\u003C/ButtonText\u003E\r\n\t\t\t\t\u003C/Strings\u003E\r\n\t\t\t\u003C/Button\u003E\r\n\t\t\t\r\n\t\t\u003C/Buttons\u003E\r\n\r\n\t\t\u003CBitmaps\u003E\r\n\t\t\t\u003CBitmap guid=\u0022guidImages\u0022 href=\u0022Resources\\OpenInFileExplorerCommand.png\u0022 usedList=\u0022bmpPic1, bmpPic2, bmpPicSearch, bmpPicX, bmpPicArrows, bmpPicStrikethrough\u0022/\u003E\r\n\t\t\u003C/Bitmaps\u003E\r\n\t\u003C/Commands\u003E\r\n\r\n\t\u003CSymbols\u003E\r\n\t\t\u003C!-- Package GUID --\u003E\r\n\t\t\u003CGuidSymbol name=\u0022guidVSExtensionDemoPackage\u0022 value=\u0022{463871e1-83b4-4c3e-953b-af3b4061e284}\u0022 /\u003E\r\n\r\n\t\t\u003C!-- Command Set GUID --\u003E\r\n\t\t\u003CGuidSymbol name=\u0022guidVSExtensionDemoPackageCmdSet\u0022 value=\u0022{1ba84305-8cf4-438f-90b7-557a332aceca}\u0022\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022EditorContextMenuGroup\u0022 value=\u00220x1020\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022OpenInExplorerCommandId\u0022 value=\u00220x0100\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022OpenInScoreTFSCommandId\u0022 value=\u00220x0101\u0022 /\u003E\r\n\t\t\u003C/GuidSymbol\u003E\r\n\r\n\t\t\u003C!-- Image GUID --\u003E\r\n\t\t\u003CGuidSymbol name=\u0022guidImages\u0022 value=\u0022{96e21caa-2683-4865-84b1-61043d5a2fa2}\u0022 \u003E\r\n\t\t\t\u003CIDSymbol name=\u0022bmpPic1\u0022 value=\u00221\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022bmpPic2\u0022 value=\u00222\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022bmpPicSearch\u0022 value=\u00223\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022bmpPicX\u0022 value=\u00224\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022bmpPicArrows\u0022 value=\u00225\u0022 /\u003E\r\n\t\t\t\u003CIDSymbol name=\u0022bmpPicStrikethrough\u0022 value=\u00226\u0022 /\u003E\r\n\t\t\u003C/GuidSymbol\u003E\r\n\t\u003C/Symbols\u003E\r\n\u003C/CommandTable\u003E\r\n"
  },
  {
    "path": "Scratchpad.VSExtensionDemo\\Properties\\AssemblyInfo.cs",
    "content": "using System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\n\r\n// General Information about an assembly is controlled through the following\r\n// set of attributes. Change these attribute values to modify the information\r\n// associated with an assembly.\r\n[assembly: AssemblyTitle(\u0022VSExtensionDemo\u0022)]\r\n[assembly: AssemblyDescription(\u0022\u0022)]\r\n[assembly: AssemblyConfiguration(\u0022\u0022)]\r\n[assembly: AssemblyCompany(\u0022\u0022)]\r\n[assembly: AssemblyProduct(\u0022VSExtensionDemo\u0022)]\r\n[assembly: AssemblyCopyright(\u0022\u0022)]\r\n[assembly: AssemblyTrademark(\u0022\u0022)]\r\n[assembly: AssemblyCulture(\u0022\u0022)]\r\n\r\n// Setting ComVisible to false makes the types in this assembly not visible\r\n// to COM components.  If you need to access a type in this assembly from\r\n// COM, set the ComVisible attribute to true on that type.\r\n[assembly: ComVisible(false)]\r\n\r\n// Version information for an assembly consists of the following four values:\r\n//\r\n//      Major Version\r\n//      Minor Version\r\n//      Build Number\r\n//      Revision\r\n//\r\n// You can specify all the values or you can default the Build and Revision Numbers\r\n// by using the \u0027*\u0027 as shown below:\r\n// [assembly: AssemblyVersion(\u00221.0.*\u0022)]\r\n[assembly: AssemblyVersion(\u00221.0.0.0\u0022)]\r\n[assembly: AssemblyFileVersion(\u00221.0.0.0\u0022)]\r\n"
  },
  {
    "path": "Scratchpad.Ollama\\Program.cs",
    "content": "using System.ComponentModel;\r\nusing System.Text;\r\nusing Microsoft.Extensions.AI;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Hosting;\r\nusing Microsoft.Extensions.Logging;\r\n\r\nvar builder = Host.CreateApplicationBuilder();\r\n\r\nconst string model = \u0022llama3.2\u0022;\r\n\r\n//const string model = \u0022deepseek-r1:1.5b\u0022;\r\n\r\nbuilder.Services.AddLogging(builder =\u003E\r\n{\r\n    builder.AddConsole();\r\n});\r\n\r\nvar ollamaChatClient = new OllamaChatClient(new Uri(\u0022http://localhost:11434\u0022), model)\r\n    .AsBuilder()\r\n    .UseFunctionInvocation()\r\n    //.UseLogging()\r\n    .Build();\r\n\r\nbuilder.Services.AddChatClient(ollamaChatClient);\r\n\r\nvar app = builder.Build();\r\n\r\nvar chatClient = app.Services.GetRequiredService\u003CIChatClient\u003E();\r\n\r\nList\u003CChatMessage\u003E messages =\r\n[\r\n    //new ChatMessage(\r\n    //    ChatRole.System,\r\n    //    \u0022\u0022\u0022\r\n    //    You are a helpful assistant. You have a single tool available to you: GetWeather. You use the tools available to you only when necessary.\r\n    //    \u0022\u0022\u0022\r\n    //),\r\n];\r\n\r\n[Description(\u0022Gets the weather\u0022)]\r\nstatic string GetWeather() =\u003E\r\n    Random.Shared.NextDouble() \u003E 0.5\r\n        ? \u0022It\u0027s sunny and ... (complete it yourself)\u0022\r\n        : \u0022It\u0027s raining and ... (complete it yourself)\u0022;\r\n\r\n//static string GetWeather() =\u003E \u0022Its dark and haily outside.\u0022;\r\n\r\nvar chatOptions = new ChatOptions\r\n{\r\n    Tools = [AIFunctionFactory.Create(GetWeather)],\r\n    //ResponseFormat = ChatResponseFormat.Text\r\n};\r\n\r\nvar cts = new CancellationTokenSource();\r\n\r\nwhile (true)\r\n{\r\n    Console.Write(\u0022Enter your prompt: \u0022);\r\n    var userMessage = Console.ReadLine()!;\r\n    messages.Add(new ChatMessage(ChatRole.User, userMessage));\r\n\r\n    var assistantResponseBuilder = new StringBuilder();\r\n\r\n    var responseStream = chatClient.GetStreamingResponseAsync(messages, chatOptions, cts.Token);\r\n\r\n    await foreach (var responseUpdate in responseStream)\r\n    {\r\n        Console.Write(responseUpdate.Text);\r\n        assistantResponseBuilder.Append(responseUpdate.Text);\r\n    }\r\n\r\n    messages.Add(new ChatMessage(ChatRole.Assistant, assistantResponseBuilder.ToString()));\r\n    Console.WriteLine();\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Ollama\\Scratchpad.Ollama.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Etrue\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.AI\u0022 Version=\u00229.3.0-preview.1.25114.11\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.AI.Ollama\u0022 Version=\u00229.3.0-preview.1.25114.11\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.Hosting\u0022 Version=\u00229.0.2\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Scratchpad.Lib\\AppJsonSerializerContext.cs",
    "content": "using System.Text.Json.Serialization;\r\nusing Scratchpad.Lib.Model;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\n[JsonSourceGenerationOptions(\r\n    WriteIndented = true,\r\n    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase\r\n)]\r\n[JsonSerializable(typeof(UserCredentials))]\r\npublic partial class AppJsonSerializerContext : JsonSerializerContext { }\r\n"
  },
  {
    "path": "Scratchpad.Lib\\DirectoryPacker.cs",
    "content": "using System.Text.Json;\r\nusing Scratchpad.Lib.Abstractions;\r\nusing Scratchpad.Lib.Model;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\npublic class DirectoryPacker : IDirectoryPacker\r\n{\r\n    private static readonly JsonSerializerOptions jsonSerializerOptions = new()\r\n    {\r\n        WriteIndented = true,\r\n    };\r\n\r\n    public async Task Pack(\r\n        string basePath,\r\n        string outputFilePath,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        List\u003CFileData\u003E importData = [];\r\n\r\n        foreach (\r\n            var filePath in FileEnumerator.EnumerateFiles(\r\n                basePath,\r\n                IncludeFiles,\r\n                IgnoreDirectories,\r\n                cancellationToken: cancellationToken\r\n            )\r\n        )\r\n        {\r\n            importData.Add(\r\n                new FileData(\r\n                    Path.GetRelativePath(basePath, filePath),\r\n                    await File.ReadAllTextAsync(filePath, cancellationToken)\r\n                )\r\n            );\r\n        }\r\n\r\n        await File.WriteAllTextAsync(\r\n            outputFilePath,\r\n            JsonSerializer.Serialize(importData, jsonSerializerOptions),\r\n            cancellationToken\r\n        );\r\n    }\r\n\r\n    public async Task Unpack(\r\n        string importFilePath,\r\n        string outputDirectoryPath,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        var importFileContent = await File.ReadAllTextAsync(importFilePath, cancellationToken);\r\n        var importData =\r\n            JsonSerializer.Deserialize\u003CList\u003CFileData\u003E\u003E(importFileContent)\r\n            ?? throw new Exception(\u0022Import data not found or not valid json.\u0022);\r\n\r\n        foreach (var fileData in importData)\r\n        {\r\n            var filePath = Path.Combine(outputDirectoryPath, fileData.Path);\r\n\r\n            var dirPath = Path.GetDirectoryName(filePath)!;\r\n\r\n            if (!Directory.Exists(dirPath))\r\n            {\r\n                Directory.CreateDirectory(dirPath);\r\n            }\r\n\r\n            await File.WriteAllTextAsync(filePath, fileData.Content, cancellationToken);\r\n        }\r\n    }\r\n\r\n    private static bool IncludeFiles(string path)\r\n    {\r\n        var ext = Path.GetExtension(path);\r\n\r\n        return ext == \u0022.cs\u0022\r\n            || ext == \u0022.csproj\u0022\r\n            || ext == \u0022.sln\u0022\r\n            || ext == \u0022.editorconfig\u0022\r\n            || ext == \u0022.xaml\u0022\r\n            || ext == \u0022.vsct\u0022\r\n            || ext == \u0022.vsixmanifest\u0022;\r\n    }\r\n\r\n    private static bool IgnoreDirectories(string path)\r\n    {\r\n        return path.Contains(\u0022bin\u0022) || path.Contains(\u0022obj\u0022);\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\DIRegistrations.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing Scratchpad.Lib.Abstractions;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\npublic static class DIRegistrations\r\n{\r\n    public static IServiceCollection AddScratchPadLib(this IServiceCollection services)\r\n    {\r\n        services.AddSingleton\u003CISecureStorage, DpapiSecureStorage\u003E();\r\n        services.AddSingleton\u003CIDirectoryPacker, DirectoryPacker\u003E();\r\n\r\n        return services;\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\DpapiSecureStorage.cs",
    "content": "using System.Security.Cryptography;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing Scratchpad.Lib.Abstractions;\r\nusing Scratchpad.Lib.Model;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\ninternal sealed class DpapiSecureStorage : ISecureStorage\r\n{\r\n    //private static readonly string _filePath = Path.Combine(\r\n    //    Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),\r\n    //    \u0022RemoteClipboard\u0022,\r\n    //    \u0022credentials.dat\u0022\r\n    //);\r\n\r\n    private static readonly string _filePath = Path.Combine(\r\n        Environment.CurrentDirectory,\r\n        \u0022encryptedcredentials.dat\u0022\r\n    );\r\n\r\n    public DpapiSecureStorage()\r\n    {\r\n        var directory = Path.GetDirectoryName(_filePath);\r\n        if (!Directory.Exists(directory))\r\n        {\r\n            Directory.CreateDirectory(directory!);\r\n        }\r\n    }\r\n\r\n    public async Task SaveCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        try\r\n        {\r\n            var json = JsonSerializer.Serialize(\r\n                userCredentials,\r\n                AppJsonSerializerContext.Default.UserCredentials\r\n            );\r\n            var dataToEncrypt = Encoding.UTF8.GetBytes(json);\r\n            var encryptedData = ProtectedData.Protect(\r\n                dataToEncrypt,\r\n                null,\r\n                DataProtectionScope.CurrentUser\r\n            );\r\n\r\n            await File.WriteAllBytesAsync(_filePath, encryptedData, cancellationToken);\r\n        }\r\n        catch { }\r\n    }\r\n\r\n    public async Task\u003CUserCredentials?\u003E GetCredentials(\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        try\r\n        {\r\n            if (!File.Exists(_filePath))\r\n                return null;\r\n\r\n            var encryptedData = await File.ReadAllBytesAsync(_filePath, cancellationToken);\r\n            var decryptedData = ProtectedData.Unprotect(\r\n                encryptedData,\r\n                null,\r\n                DataProtectionScope.CurrentUser\r\n            );\r\n\r\n            var json = Encoding.UTF8.GetString(decryptedData);\r\n\r\n            return JsonSerializer.Deserialize(\r\n                json,\r\n                AppJsonSerializerContext.Default.UserCredentials\r\n            );\r\n        }\r\n        catch\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void DeleteCredentials()\r\n    {\r\n        try\r\n        {\r\n            File.Delete(_filePath);\r\n        }\r\n        catch\r\n        {\r\n            // Handle deletion errors\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\DpapiSecureStorage2.cs",
    "content": "using System.Text;\r\nusing System.Text.Json;\r\nusing Microsoft.AspNetCore.DataProtection;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Scratchpad.Lib.Abstractions;\r\nusing Scratchpad.Lib.Model;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\ninternal sealed class DpapiSecureStorage2 : ISecureStorage\r\n{\r\n    private readonly IDataProtector _dataProtector;\r\n\r\n    public DpapiSecureStorage2(IDataProtectionProvider dataProtectionProvider)\r\n    {\r\n        _dataProtector = dataProtectionProvider.CreateProtector(\u0022Wowzer\u0022);\r\n    }\r\n\r\n    public async Task SaveCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        try\r\n        {\r\n            var json = JsonSerializer.Serialize(\r\n                userCredentials,\r\n                AppJsonSerializerContext.Default.UserCredentials\r\n            );\r\n            var dataToEncrypt = Encoding.UTF8.GetBytes(json);\r\n            var encryptedData = _dataProtector.Protect(dataToEncrypt);\r\n        }\r\n        catch { }\r\n    }\r\n\r\n    public async Task\u003CUserCredentials?\u003E GetCredentials(\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        try\r\n        {\r\n            //var encryptedData = await File.ReadAllBytesAsync(_filePath, cancellationToken);\r\n            byte[] encryptedData = [1, 2, 3];\r\n            var decryptedData = _dataProtector.Unprotect(encryptedData);\r\n\r\n            var json = Encoding.UTF8.GetString(decryptedData);\r\n\r\n            return JsonSerializer.Deserialize(\r\n                json,\r\n                AppJsonSerializerContext.Default.UserCredentials\r\n            );\r\n        }\r\n        catch\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void DeleteCredentials()\r\n    {\r\n        try\r\n        {\r\n            //File.Delete(_filePath);\r\n        }\r\n        catch\r\n        {\r\n            // Handle deletion errors\r\n        }\r\n    }\r\n\r\n    public static void Register(IServiceCollection serviceCollection)\r\n    {\r\n        serviceCollection\r\n            .AddDataProtection()\r\n            .PersistKeysToFileSystem(new DirectoryInfo(Environment.CurrentDirectory))\r\n            .ProtectKeysWithDpapi();\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\FileEnumerator.cs",
    "content": "using System.Diagnostics;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\npublic static class FileEnumerator\r\n{\r\n    public static void Demo(string[]? args = null)\r\n    {\r\n        var sw = Stopwatch.StartNew();\r\n\r\n        var cts = new CancellationTokenSource(1000);\r\n\r\n        static bool Hello(string path)\r\n        {\r\n            return path.Contains(\u0022venv\u0022)\r\n                || path.Contains(\u0022node_modules\u0022)\r\n                || path.Contains(\u0022bin\u0022)\r\n                || path.Contains(\u0022obj\u0022);\r\n        }\r\n\r\n        static bool Hello2(string path)\r\n        {\r\n            string[] strings = [\u0022venv\u0022, \u0022node_modules\u0022, \u0022bin\u0022, \u0022obj\u0022];\r\n\r\n            return strings.Any(path.Contains);\r\n        }\r\n\r\n        var files = FileEnumerator.EnumerateFiles(\r\n            @\u0022C:\\users\\user\\projects\u0022,\r\n            includeFilePredicate: path =\u003E path.Contains(\u0022hello\u0022),\r\n            ignoreDirPredicate: Hello2,\r\n            cancellationToken: cts.Token\r\n        );\r\n\r\n        foreach (var file in files)\r\n        {\r\n            Console.WriteLine(file);\r\n        }\r\n\r\n        //Console.WriteLine(files.Count());\r\n\r\n        //Console.WriteLine(string.Join(\u0027\\n\u0027, files));\r\n\r\n        Console.WriteLine(sw.Elapsed.TotalMilliseconds);\r\n    }\r\n\r\n    public static IEnumerable\u003Cstring\u003E EnumerateFiles(\r\n        string rootPath,\r\n        Func\u003Cstring, bool\u003E? includeFilePredicate = null,\r\n        Func\u003Cstring, bool\u003E? ignoreDirPredicate = null,\r\n        EnumerationOptions? enumerationOptions = null,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        if (!Directory.Exists(rootPath))\r\n        {\r\n            throw new DirectoryNotFoundException($\u0022Directory not found: {rootPath}\u0022);\r\n        }\r\n\r\n        includeFilePredicate ??= _ =\u003E true;\r\n        ignoreDirPredicate ??= _ =\u003E false;\r\n\r\n        enumerationOptions ??= new EnumerationOptions { IgnoreInaccessible = true };\r\n\r\n        var directoryStack = new Stack\u003Cstring\u003E();\r\n        directoryStack.Push(rootPath);\r\n\r\n        while (directoryStack.Count \u003E 0)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n            var currentPath = directoryStack.Pop();\r\n\r\n            foreach (var filePath in Directory.EnumerateFiles(currentPath, \u0022*\u0022, enumerationOptions))\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n                if (includeFilePredicate(filePath))\r\n                {\r\n                    yield return filePath;\r\n                }\r\n            }\r\n\r\n            foreach (\r\n                var dirPath in Directory.EnumerateDirectories(currentPath, \u0022*\u0022, enumerationOptions)\r\n            )\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n                if (!ignoreDirPredicate(dirPath))\r\n                {\r\n                    directoryStack.Push(dirPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\Pipeline.cs",
    "content": "using System.Diagnostics;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Xml.Linq;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\npublic class Pipeline\r\n{\r\n    readonly record struct Project(string Name, string FileName, string Guid, string RelativePath);\r\n\r\n    private static void TransformRepository(\r\n        IEnumerable\u003Cstring\u003E csprojFilePathList,\r\n        List\u003Cstring\u003E unusedProjects,\r\n        string packagesDirectoryPath,\r\n        string allProjectPath,\r\n        List\u003CProject\u003E projectList\r\n    )\r\n    {\r\n        foreach (var csprojFilePath in csprojFilePathList)\r\n        {\r\n            var projectFileName = Path.GetFileName(csprojFilePath);\r\n\r\n            if (unusedProjects.Contains(projectFileName))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            var projectRootPath = Path.GetDirectoryName(csprojFilePath)!;\r\n            var csprojFileContent = File.ReadAllText(csprojFilePath);\r\n            var relativePackageDirectoryPath = Path.GetRelativePath(\r\n                projectRootPath,\r\n                packagesDirectoryPath\r\n            );\r\n\r\n            var matchPackagePattern = @\u0022(\\.\\.\\\\)\u002Bpackages\u0022; // regex for ..\\packages or ..\\..\\packages or ..\\..\\..\\packages or ...etc\r\n\r\n            var replacedCsprojFileContent = Regex.Replace(\r\n                csprojFileContent,\r\n                matchPackagePattern,\r\n                relativePackageDirectoryPath\r\n            );\r\n\r\n            var csprojXml = XDocument.Parse(replacedCsprojFileContent);\r\n\r\n            var projectGuid = Guid.NewGuid().ToString();\r\n\r\n            var hintPaths = csprojXml.Descendants().Where(x =\u003E x.Name.LocalName == \u0022HintPath\u0022);\r\n\r\n            var project = new Project(\r\n                projectFileName[..projectFileName.LastIndexOf(\u0027.\u0027)],\r\n                projectFileName,\r\n                projectGuid,\r\n                Path.GetRelativePath(allProjectPath, csprojFilePath)\r\n            );\r\n\r\n            projectList.Add(project);\r\n\r\n            foreach (var hintPathNode in hintPaths)\r\n            {\r\n                // This step should be retired, these should be replaced with project references anyway\r\n                const string debugPattern = @\u0022\\bin\\Debug\u0022;\r\n                const string releasePattern = @\u0022\\bin\\Release\u0022;\r\n                if (hintPathNode.Value.Contains(debugPattern, StringComparison.OrdinalIgnoreCase))\r\n                {\r\n                    Console.WriteLine($\u0022{projectFileName}: {hintPathNode.Value}\u0022);\r\n                    hintPathNode.Value = hintPathNode.Value.Replace(\r\n                        debugPattern,\r\n                        releasePattern,\r\n                        StringComparison.OrdinalIgnoreCase\r\n                    );\r\n                }\r\n\r\n                // Replace relative package references with repository package store\r\n                const string packagePattern = @\u0022\\packages\\\u0022;\r\n                var idx = hintPathNode.Value.IndexOf(\r\n                    packagePattern,\r\n                    StringComparison.OrdinalIgnoreCase\r\n                );\r\n                if (\r\n                    idx != -1\r\n                    \u0026\u0026 !hintPathNode.Value.StartsWith(\r\n                        relativePackageDirectoryPath,\r\n                        StringComparison.OrdinalIgnoreCase\r\n                    )\r\n                )\r\n                {\r\n                    hintPathNode.Value =\r\n                        @$\u0022{relativePackageDirectoryPath}\\{hintPathNode.Value[(idx \u002B packagePattern.Length)..]}\u0022;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            csprojXml.Save(csprojFilePath);\r\n        }\r\n    }\r\n\r\n    public static void Run(\r\n        string basePath,\r\n        string packagesDirectoryPath,\r\n        string nugetConfigFilePath,\r\n        bool restorePackages,\r\n        bool cleanBinObj,\r\n        bool cleanPackages,\r\n        string slnFileName\r\n    )\r\n    {\r\n        var sw = Stopwatch.StartNew();\r\n        var sw2 = Stopwatch.StartNew();\r\n\r\n        double timeTakenNugetRestore = -1;\r\n        double timeTakenTotal = -1;\r\n        double timeTakenBuild = -1;\r\n        double timeTakenRepositoryTransform = -1;\r\n\r\n        if (cleanBinObj)\r\n        {\r\n            PipelineUtils.CleanSolution(basePath, cleanPackages);\r\n            Console.WriteLine($\u0022Clean completed in {sw2.Elapsed.TotalSeconds} seconds.\u0022);\r\n            sw2.Restart();\r\n        }\r\n\r\n        Console.WriteLine($\u0022Listing projects in {basePath}\u0022);\r\n\r\n        IEnumerable\u003Cstring\u003E csprojFilePathList = Directory.EnumerateFiles(\r\n            basePath,\r\n            \u0022*.csproj\u0022,\r\n            SearchOption.AllDirectories\r\n        );\r\n\r\n        var allProjectPath = Path.Combine(basePath, \u0022AllProject\u0022);\r\n        var projectList = new List\u003CProject\u003E();\r\n\r\n        // Maybe read this part from a config file\r\n        List\u003Cstring\u003E unusedProjects = [];\r\n\r\n        TransformRepository(\r\n            csprojFilePathList,\r\n            unusedProjects,\r\n            packagesDirectoryPath,\r\n            allProjectPath,\r\n            projectList\r\n        );\r\n        Console.WriteLine(\u0022Transformed repository successfully.\u0022);\r\n        Environment.Exit(0);\r\n\r\n        var slnPath = Path.Combine(allProjectPath, slnFileName);\r\n        CreateSlnFile(projectList, slnPath);\r\n\r\n        timeTakenRepositoryTransform = sw2.Elapsed.TotalSeconds;\r\n        sw2.Restart();\r\n\r\n        if (restorePackages)\r\n        {\r\n            PipelineUtils.NugetRestore(\r\n                slnPath,\r\n                basePath,\r\n                nugetConfigFilePath,\r\n                packagesDirectoryPath\r\n            );\r\n            timeTakenNugetRestore = sw2.Elapsed.TotalSeconds;\r\n            sw2.Restart();\r\n        }\r\n\r\n        BuildSolution(\r\n            slnPath,\r\n            basePath,\r\n            usedCores: 0,\r\n            minimalVerbosity: false,\r\n            logErrorsOnly: true\r\n        );\r\n\r\n        timeTakenBuild = sw2.Elapsed.TotalSeconds;\r\n        timeTakenTotal = sw.Elapsed.TotalSeconds;\r\n\r\n        Console.WriteLine($\u0022Nuget restore completed in {timeTakenNugetRestore} seconds.\u0022);\r\n        Console.WriteLine($\u0022Repository transformed in {timeTakenRepositoryTransform} seconds.\u0022);\r\n        Console.WriteLine($\u0022Build completed in {timeTakenBuild} seconds.\u0022);\r\n        Console.WriteLine($\u0022\\n-------\\nTotal time taken: {timeTakenTotal} seconds.\u0022);\r\n    }\r\n\r\n    private static void CreateSlnFile(List\u003CProject\u003E projectList, string filePath)\r\n    {\r\n        var sb = new StringBuilder(\r\n            \u0022\u0022\u0022\r\n            Microsoft Visual Studio Solution File, Format Version 12.00\r\n            # Visual Studio Version 17\r\n            VisualStudioVersion = 17.0.32014.148\r\n            MinimumVisualStudioVersion = 10.0.40219.1\r\n\r\n            \u0022\u0022\u0022\r\n        );\r\n\r\n        const string projectTypeGuid = \u0022FAE04EC0-301F-11D3-BF4B-00C04F79EFBC\u0022;\r\n\r\n        foreach (var project in projectList)\r\n        {\r\n            sb.AppendLine(\r\n                $\u0022Project(\\\u0022{{{projectTypeGuid}}}\\\u0022) = \\\u0022{project.Name}\\\u0022, \\\u0022{project.RelativePath}\\\u0022, \\\u0022{project.Guid}\\\u0022\u0022\r\n            );\r\n            sb.AppendLine(\u0022EndProject\u0022);\r\n        }\r\n\r\n        sb.AppendLine(\u0022Global\u0022);\r\n        sb.AppendLine(\u0022\\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\u0022);\r\n        sb.AppendLine(\u0022\\t\\tDebug|Any CPU = Debug|Any CPU\u0022);\r\n        sb.AppendLine(\u0022\\t\\tRelease|Any CPU = Release|Any CPU\u0022);\r\n        sb.AppendLine(\u0022\\tEndGlobalSection\u0022);\r\n\r\n        sb.AppendLine(\u0022\\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\u0022);\r\n\r\n        foreach (var project in projectList)\r\n        {\r\n            sb.AppendLine($\u0022\\t\\t{project.Guid}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\u0022);\r\n            sb.AppendLine($\u0022\\t\\t{project.Guid}.Debug|Any CPU.Build.0 = Debug|Any CPU\u0022);\r\n            sb.AppendLine($\u0022\\t\\t{project.Guid}.Release|Any CPU.ActiveCfg = Release|Any CPU\u0022);\r\n            sb.AppendLine($\u0022\\t\\t{project.Guid}.Release|Any CPU.Build.0 = Release|Any CPU\u0022);\r\n        }\r\n\r\n        sb.AppendLine(\u0022\\tEndGlobalSection\u0022);\r\n        sb.AppendLine(\u0022EndGlobal\u0022);\r\n\r\n        File.WriteAllText(filePath, sb.ToString());\r\n    }\r\n\r\n    private static void BuildSolution(\r\n        string buildPath,\r\n        string workingDirectory,\r\n        int usedCores = 0,\r\n        bool minimalVerbosity = false,\r\n        bool logErrorsOnly = false\r\n    )\r\n    {\r\n        const string msbuildExePath = @\u0022C:\\Program Files (x86)\\MSBuild\\14.0\\bin\\msbuild.exe\u0022;\r\n\r\n        var identifier = Path.GetFileName(buildPath);\r\n        var logPath = Path.Combine(workingDirectory, \u0022BuildLogs\u0022);\r\n        var verbosity = minimalVerbosity ? \u0022minimal\u0022 : \u0022normal\u0022;\r\n\r\n        if (!Directory.Exists(logPath))\r\n        {\r\n            Directory.CreateDirectory(logPath);\r\n        }\r\n\r\n        var logFilePath = Path.Combine(logPath, $\u0022{identifier}_BuildErrors.log\u0022);\r\n\r\n        var commandBuilder = new StringBuilder(buildPath);\r\n\r\n        commandBuilder.Append(\u0022 /nologo\u0022);\r\n        commandBuilder.Append(\u0022 /nr:false\u0022);\r\n        commandBuilder.Append(\u0022 /p:WarningLevel=0\u0022);\r\n        commandBuilder.Append(\u0022 /p:platform=\\\u0022Any CPU\\\u0022\u0022);\r\n        commandBuilder.Append(\u0022 /p:configuration=\\\u0022Release\\\u0022\u0022);\r\n        commandBuilder.Append(\u0022 /p:VisualStudioVersion=\\\u002214.0\\\u0022\u0022);\r\n\r\n        commandBuilder.Append(usedCores == 0 ? \u0022 /m\u0022 : $\u0022 /m:{usedCores}\u0022);\r\n\r\n        // /bl for understanding how its built -bl:{logfilePath}build.binlog\r\n        commandBuilder.Append($\u0022 /fileLogger /flp:logfile={logFilePath};verbosity={verbosity}\u0022);\r\n\r\n        if (logErrorsOnly)\r\n        {\r\n            commandBuilder.Append(\u0022;errorsonly\u0022);\r\n        }\r\n\r\n        using var process = PipelineUtils.StartProcessAndReadOutput(\r\n            msbuildExePath,\r\n            commandBuilder.ToString(),\r\n            workingDirectory\r\n        );\r\n\r\n        process.WaitForExit();\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\PipelineUtils.cs",
    "content": "using System.Diagnostics;\r\nusing System.Text;\r\n\r\nnamespace Scratchpad.Lib;\r\n\r\npublic static class PipelineUtils\r\n{\r\n    public static Process StartProcessAndReadOutput(\r\n        string filename,\r\n        string arguments,\r\n        string workingDirectory\r\n    )\r\n    {\r\n        var process =\r\n            Process.Start(\r\n                new ProcessStartInfo\r\n                {\r\n                    FileName = filename,\r\n                    Arguments = arguments,\r\n                    UseShellExecute = false,\r\n                    RedirectStandardOutput = true,\r\n                    RedirectStandardError = true,\r\n                    CreateNoWindow = true,\r\n                    WorkingDirectory = workingDirectory,\r\n                }\r\n            ) ?? throw new Exception(\u0022An error occurred while starting process\u0022);\r\n\r\n        process.OutputDataReceived \u002B= (sender, e) =\u003E\r\n        {\r\n            if (!string.IsNullOrEmpty(e.Data))\r\n            {\r\n                Console.WriteLine(e.Data);\r\n            }\r\n        };\r\n\r\n        process.ErrorDataReceived \u002B= (sender, e) =\u003E\r\n        {\r\n            if (!string.IsNullOrEmpty(e.Data))\r\n            {\r\n                Console.WriteLine(e.Data);\r\n            }\r\n        };\r\n\r\n        process.BeginOutputReadLine();\r\n        process.BeginErrorReadLine();\r\n\r\n        return process;\r\n    }\r\n\r\n    public static void CloneRepository(\r\n        string repoUrl,\r\n        string branchName,\r\n        string workingDirectory,\r\n        string? directoryName = null\r\n    )\r\n    {\r\n        var sw = Stopwatch.StartNew();\r\n\r\n        using var process = StartProcessAndReadOutput(\r\n            \u0022git\u0022,\r\n            $\u0022clone --single-branch --branch {branchName} --depth 1 --no-tags {repoUrl} {directoryName ?? string.Empty}\u0022,\r\n            workingDirectory\r\n        );\r\n\r\n        process.WaitForExit();\r\n\r\n        Console.WriteLine($\u0022Time taken: {sw.Elapsed.TotalSeconds} seconds\u0022);\r\n    }\r\n\r\n    public static void NugetRestore(\r\n        string solutionPath,\r\n        string workingDirectory = \u0022\u0022,\r\n        string configFilePath = \u0022\u0022,\r\n        string packagesDirectoryPath = \u0022\u0022\r\n    )\r\n    {\r\n        var sw = Stopwatch.StartNew();\r\n\r\n        var commandBuilder = new StringBuilder(\r\n            $\u0022restore {solutionPath} -NoCache -Verbosity Detailed -NonInteractive\u0022\r\n        );\r\n\r\n        if (!string.IsNullOrWhiteSpace(configFilePath))\r\n        {\r\n            commandBuilder.Append($\u0022 -ConfigFile {configFilePath}\u0022);\r\n        }\r\n\r\n        if (!string.IsNullOrWhiteSpace(packagesDirectoryPath))\r\n        {\r\n            commandBuilder.Append($\u0022 -PackagesDirectory {packagesDirectoryPath}\u0022);\r\n        }\r\n\r\n        using var process = StartProcessAndReadOutput(\r\n            \u0022nuget\u0022,\r\n            commandBuilder.ToString(),\r\n            workingDirectory\r\n        );\r\n\r\n        process.WaitForExit();\r\n\r\n        Console.WriteLine($\u0022Time taken: {sw.Elapsed.TotalSeconds} seconds\u0022);\r\n    }\r\n\r\n    public static void CleanSolution(\r\n        string baseDirectory,\r\n        bool deletePackages = false,\r\n        bool printDeleted = false\r\n    )\r\n    {\r\n        var sw = Stopwatch.StartNew();\r\n\r\n        var objBinDirectoryList = Directory.EnumerateDirectories(\r\n            baseDirectory,\r\n            \u0022*\u0022,\r\n            SearchOption.AllDirectories\r\n        );\r\n\r\n        if (deletePackages)\r\n        {\r\n            objBinDirectoryList = objBinDirectoryList.Where(x =\u003E\r\n                Path.GetFileName(x).Equals(\u0022bin\u0022, StringComparison.OrdinalIgnoreCase)\r\n                || Path.GetFileName(x).Equals(\u0022obj\u0022, StringComparison.OrdinalIgnoreCase)\r\n                || Path.GetFileName(x).Equals(\u0022packages\u0022, StringComparison.OrdinalIgnoreCase)\r\n            );\r\n        }\r\n        else\r\n        {\r\n            objBinDirectoryList = objBinDirectoryList.Where(x =\u003E\r\n                Path.GetFileName(x).Equals(\u0022bin\u0022, StringComparison.OrdinalIgnoreCase)\r\n                || Path.GetFileName(x).Equals(\u0022obj\u0022, StringComparison.OrdinalIgnoreCase)\r\n            );\r\n        }\r\n\r\n        Parallel.ForEach(\r\n            objBinDirectoryList,\r\n            new ParallelOptions { MaxDegreeOfParallelism = 4 },\r\n            (dir) =\u003E\r\n            {\r\n                if (printDeleted)\r\n                    Console.WriteLine(dir);\r\n\r\n                Directory.Delete(dir, true);\r\n            }\r\n        );\r\n\r\n        Console.WriteLine(\r\n            $\u0022Deleted obj and bin directories for {baseDirectory} in {sw.Elapsed.TotalSeconds} seconds.\u0022\r\n        );\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\ProjectDependencyUtils.cs",
    "content": "namespace Scratchpad.Lib;\r\n\r\npublic class ProjectDependencyUtils\r\n{\r\n    public static async Task Runner()\r\n    {\r\n        var file = await File.ReadAllTextAsync(\u0022deps.json\u0022);\r\n        //var file = await File.ReadAllTextAsync(\u0022reverse-deps.json\u0022);\r\n        //var dependencyGraph = JsonSerializer.Deserialize\u003CDictionary\u003Cstring, List\u003Cstring\u003E\u003E\u003E(file)!;\r\n        //var reverseDependencyGraph = CreateReverseDependencyGraph(dependencyGraph);\r\n\r\n        //var v = TopologicalSort(reverseDependencyGraph);\r\n    }\r\n\r\n    static Dictionary\u003Cstring, List\u003Cstring\u003E\u003E CreateReverseDependencyGraph(\r\n        Dictionary\u003Cstring, List\u003Cstring\u003E\u003E dependencyGraph\r\n    )\r\n    {\r\n        return dependencyGraph;\r\n    }\r\n\r\n    static List\u003Cstring\u003E TopologicalSort(Dictionary\u003Cstring, List\u003Cstring\u003E\u003E graph)\r\n    {\r\n        // Initialize in-degree for each node\r\n        var inDegree = graph.ToDictionary(node =\u003E node.Key, node =\u003E 0);\r\n\r\n        // Calculate in-degrees\r\n        foreach (var node in graph)\r\n        {\r\n            foreach (var neighbor in node.Value)\r\n            {\r\n                inDegree[neighbor]\u002B\u002B;\r\n            }\r\n        }\r\n\r\n        // Find all nodes with in-degree 0\r\n        var queue = new Queue\u003Cstring\u003E(\r\n            inDegree.Where(pair =\u003E pair.Value == 0).Select(pair =\u003E pair.Key)\r\n        );\r\n\r\n        var topoOrder = new List\u003Cstring\u003E();\r\n\r\n        while (queue.Count \u003E 0)\r\n        {\r\n            var current = queue.Dequeue();\r\n            topoOrder.Add(current);\r\n\r\n            foreach (var neighbor in graph[current])\r\n            {\r\n                inDegree[neighbor]--;\r\n                if (inDegree[neighbor] == 0)\r\n                {\r\n                    queue.Enqueue(neighbor);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check for cycles\r\n        if (topoOrder.Count != graph.Count)\r\n        {\r\n            throw new InvalidOperationException(\r\n                \u0022Graph contains a cycle, topological sort not possible.\u0022\r\n            );\r\n        }\r\n\r\n        return topoOrder;\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\Scratchpad.Lib.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003ELibrary\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022HtmlAgilityPack\u0022 Version=\u00221.12.1\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.FileSystemGlobbing\u0022 Version=\u00229.0.6\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Spectre.Console\u0022 Version=\u00220.50.0\u0022 /\u003E\r\n    \u003CPackageReference\r\n      Include=\u0022Microsoft.Extensions.DependencyInjection.Abstractions\u0022\r\n      Version=\u00229.0.7\u0022\r\n    /\u003E\r\n    \u003CPackageReference Include=\u0022System.Security.Cryptography.ProtectedData\u0022 Version=\u00229.0.7\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.AspNetCore.DataProtection\u0022 Version=\u00229.0.7\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022GlobalHotKeys.Windows\u0022 Version=\u00220.1.0\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "Scratchpad.Lib\\Model\\FileData.cs",
    "content": "namespace Scratchpad.Lib.Model;\r\n\r\npublic record FileData(string Path, string Content);\r\n"
  },
  {
    "path": "Scratchpad.Lib\\Model\\UserCredentials.cs",
    "content": "namespace Scratchpad.Lib.Model;\r\n\r\npublic record UserCredentials(string UserName, string Password);\r\n"
  },
  {
    "path": "Scratchpad.Lib\\GlobalHotkeys\\GlobalHotKeyService.cs",
    "content": "using GlobalHotKeys;\r\nusing GlobalHotKeys.Native.Types;\r\n\r\nnamespace Scratchpad.Lib.GlobalHotkeys;\r\n\r\ninternal class GlobalHotKeyService : IDisposable\r\n{\r\n    private readonly HotKeyManager hotKeyManager = new();\r\n    private readonly List\u003CIDisposable?\u003E hotKeyRegistrations = [];\r\n    private IDisposable? observableHandle;\r\n\r\n    public GlobalHotKeyService()\r\n    {\r\n        InitializeHotKeyManager();\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        observableHandle?.Dispose();\r\n        foreach (var registration in hotKeyRegistrations)\r\n        {\r\n            registration?.Dispose();\r\n        }\r\n        hotKeyManager.Dispose();\r\n    }\r\n\r\n    private void InitializeHotKeyManager()\r\n    {\r\n        hotKeyRegistrations.Add(\r\n            hotKeyManager.Register(\r\n                VirtualKeyCode.KEY_A,\r\n                Modifiers.Control | Modifiers.Shift | Modifiers.NoRepeat\r\n            )\r\n        );\r\n\r\n        observableHandle = hotKeyManager.HotKeyPressed.Subscribe(async hotKey =\u003E\r\n        {\r\n            await Task.Delay(199);\r\n\r\n            Console.WriteLine($\u0022Hotkey pressed: {hotKey}\u0022);\r\n\r\n            if (hotKey.Key == VirtualKeyCode.KEY_A)\r\n            {\r\n                Console.Beep(1000, 2000);\r\n            }\r\n        });\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\FileSearch\\FileSearcher.cs",
    "content": "using System.Diagnostics;\r\nusing System.Text.RegularExpressions;\r\nusing Microsoft.Extensions.FileSystemGlobbing;\r\n\r\nnamespace Scratchpad.Lib.FileSearch;\r\n\r\npublic sealed class FileSearcher : IFileSearcher\r\n{\r\n    private const int bufferSize = 4096 * 2;\r\n\r\n    public static void Search(\r\n        string searchPattern,\r\n        string searchDirectory,\r\n        DateTimeOffset? startDate = null,\r\n        DateTimeOffset? endDate = null,\r\n        bool searchZip = false,\r\n        string includePattern = \u0022*\u0022,\r\n        string? excludePattern = null,\r\n        FileSearchOptions? fileSearchOptions = null,\r\n        ZipFileSearchOptions? zipFileSearchOptions = null\r\n    )\r\n    {\r\n        var searchRegex = new Regex(\r\n            searchPattern,\r\n            RegexOptions.Compiled | RegexOptions.IgnoreCase,\r\n            TimeSpan.FromMilliseconds(250)\r\n        );\r\n\r\n        var matcher = new Matcher().AddInclude(includePattern);\r\n\r\n        if (!string.IsNullOrWhiteSpace(excludePattern))\r\n        {\r\n            matcher.AddExclude(excludePattern);\r\n        }\r\n\r\n        var filePathEnumerator = FileEnumerator.EnumerateFiles(\r\n            searchDirectory,\r\n            includeFilePredicate: path =\u003E\r\n            {\r\n                if (!matcher.Match(searchDirectory, path).HasMatches)\r\n                {\r\n                    return false;\r\n                }\r\n\r\n                var lastWriteTime = File.GetLastWriteTime(path);\r\n\r\n                //lastWriteTime.TimeOfDay \u003E= startTime \u0026\u0026 lastWriteTime \u003C= endTime\r\n\r\n                //return lastWriteTime \u003E= startDate \u0026\u0026 lastWriteTime \u003C= endDate;\r\n\r\n                return (startDate, endDate) switch\r\n                {\r\n                    (null, null) =\u003E true,\r\n                    (not null, null) =\u003E startDate \u003C= lastWriteTime,\r\n                    (null, not null) =\u003E lastWriteTime \u003C= endDate,\r\n                    (not null, not null) =\u003E startDate \u003C= lastWriteTime \u0026\u0026 lastWriteTime \u003C= endDate,\r\n                };\r\n            }\r\n        );\r\n\r\n        var sw = Stopwatch.StartNew();\r\n\r\n        var count = 0;\r\n\r\n        foreach (var filePath in filePathEnumerator)\r\n        {\r\n            InternalSearch(filePath);\r\n            count\u002B\u002B;\r\n        }\r\n\r\n        Console.WriteLine(\r\n            $\u0022Finished searching through {count} files in {sw.Elapsed.TotalSeconds} seconds.\u0022\r\n        );\r\n\r\n        static bool IsZip(string path) =\u003E\r\n            Path.GetExtension(path)?.Equals(\u0022.zip\u0022, StringComparison.OrdinalIgnoreCase) is true;\r\n\r\n        void InternalSearch(string path)\r\n        {\r\n            try\r\n            {\r\n                var searchFileResult =\r\n                    !IsZip(path) ? SearchInFile(path, searchRegex, options: fileSearchOptions)\r\n                    : searchZip\r\n                        ? ZipFileSearcher.SearchInZip(\r\n                            path,\r\n                            searchRegex,\r\n                            options: zipFileSearchOptions,\r\n                            includeFileFilter: entry =\u003E\r\n                                matcher.Match(entry.FullName).HasMatches\r\n                                \u0026\u0026 entry.LastWriteTime \u003E= startDate\r\n                                \u0026\u0026 entry.LastWriteTime \u003C= endDate\r\n                        )\r\n                    : [];\r\n\r\n                foreach (var searchResult in searchFileResult)\r\n                {\r\n                    Log($\u0022{searchResult}\u0022);\r\n                }\r\n            }\r\n            catch (FileNotFoundException)\r\n            {\r\n                Log($\u0022Error: File not found at \u0027{path}\u0027\u0022);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static IEnumerable\u003CSearchResult\u003E SearchInFile(\r\n        string filePath,\r\n        Regex searchRegex,\r\n        FileSearchOptions? options = null\r\n    )\r\n    {\r\n        options ??= FileSearchOptions.Default;\r\n\r\n        using var stream = new FileStream(\r\n            filePath,\r\n            FileMode.Open,\r\n            FileAccess.Read,\r\n            FileShare.Read,\r\n            bufferSize,\r\n            FileOptions.SequentialScan\r\n        );\r\n\r\n        using var reader = new StreamReader(stream);\r\n\r\n        string? line;\r\n        var lineNumber = 0;\r\n        while ((line = reader.ReadLine()) != null)\r\n        {\r\n            lineNumber\u002B\u002B;\r\n            if (searchRegex.IsMatch(line))\r\n            {\r\n                yield return new(filePath, lineNumber, line);\r\n                if (options.StopWhenFound)\r\n                {\r\n                    yield break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async IAsyncEnumerable\u003CSearchResult\u003E SearchInFileAsync(\r\n        string filePath,\r\n        Regex searchRegex,\r\n        FileSearchOptions? options = null\r\n    )\r\n    {\r\n        options ??= FileSearchOptions.Default;\r\n\r\n        using var stream = new FileStream(\r\n            filePath,\r\n            FileMode.Open,\r\n            FileAccess.Read,\r\n            FileShare.Read,\r\n            bufferSize,\r\n            FileOptions.Asynchronous | FileOptions.SequentialScan\r\n        );\r\n\r\n        using var reader = new StreamReader(stream);\r\n\r\n        string? line;\r\n        var lineNumber = 0;\r\n        while ((line = await reader.ReadLineAsync().ConfigureAwait(false)) != null)\r\n        {\r\n            lineNumber\u002B\u002B;\r\n            if (searchRegex.IsMatch(line))\r\n            {\r\n                yield return new(filePath, lineNumber, line);\r\n\r\n                if (options.StopWhenFound)\r\n                {\r\n                    yield break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void Log(string message)\r\n    {\r\n        Console.WriteLine(message);\r\n    }\r\n\r\n    private static void OpenWithNpp(string path)\r\n    {\r\n        Process.Start(\r\n            new ProcessStartInfo\r\n            {\r\n                FileName = @\u0022C:\\Program Files\\Notepad\u002B\u002B\\notepad\u002B\u002B.exe\u0022,\r\n                Arguments = path,\r\n                UseShellExecute = false,\r\n                RedirectStandardOutput = true,\r\n                RedirectStandardError = true,\r\n                CreateNoWindow = true,\r\n            }\r\n        );\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\FileSearch\\IFileSearcher.cs",
    "content": "namespace Scratchpad.Lib.FileSearch;\r\n\r\ninternal interface IFileSearcher\r\n{\r\n    //Task Search(CancellationToken cancellationToken);\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\FileSearch\\Records.cs",
    "content": "namespace Scratchpad.Lib.FileSearch;\r\n\r\npublic sealed record SearchResult(string FilePath, int LineNumber, string LineContent);\r\n\r\npublic sealed record ZipFileSearchOptions(string? ExtractPath = null, bool StopWhenFound = true)\r\n{\r\n    public static readonly ZipFileSearchOptions Default = new();\r\n}\r\n\r\npublic sealed record FileSearchOptions(bool StopWhenFound = true)\r\n{\r\n    public static readonly FileSearchOptions Default = new();\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\FileSearch\\ZipFileSearcher.cs",
    "content": "using System.Diagnostics;\r\nusing System.IO.Compression;\r\nusing System.Text.RegularExpressions;\r\n\r\nnamespace Scratchpad.Lib.FileSearch;\r\n\r\npublic sealed class ZipFileSearcher : IFileSearcher\r\n{\r\n    public static IEnumerable\u003CSearchResult\u003E SearchInZip(\r\n        string zipFilePath,\r\n        Regex searchRegex,\r\n        Func\u003CZipArchiveEntry, bool\u003E? includeFileFilter = null,\r\n        Func\u003CZipArchiveEntry, bool\u003E? excludeFileFilter = null,\r\n        ZipFileSearchOptions? options = null\r\n    )\r\n    {\r\n        try\r\n        {\r\n            return SearchInZipInternal(\r\n                zipFilePath,\r\n                searchRegex,\r\n                includeFileFilter,\r\n                excludeFileFilter,\r\n                options\r\n            );\r\n        }\r\n        catch (InvalidDataException)\r\n        {\r\n            //Log($\u0022Error: The file at \u0027{zipFilePath}\u0027 is not a valid zip archive.\u0022);\r\n            return [];\r\n        }\r\n        catch (Exception ex) when (ex is not FileNotFoundException)\r\n        {\r\n            //Log($\u0022An unexpected error occurred: {ex.Message}\u0022);\r\n            return [];\r\n        }\r\n    }\r\n\r\n    private static IEnumerable\u003CSearchResult\u003E SearchInZipInternal(\r\n        string zipFilePath,\r\n        Regex searchRegex,\r\n        Func\u003CZipArchiveEntry, bool\u003E? includeFileFilter = null,\r\n        Func\u003CZipArchiveEntry, bool\u003E? excludeFileFilter = null,\r\n        ZipFileSearchOptions? options = null\r\n    )\r\n    {\r\n        options ??= ZipFileSearchOptions.Default;\r\n        includeFileFilter ??= _ =\u003E true;\r\n        excludeFileFilter ??= _ =\u003E false;\r\n\r\n        // Warning: This stream is not thread safe\r\n        using var archive = ZipFile.OpenRead(zipFilePath);\r\n\r\n        List\u003Cstring\u003E tp = [];\r\n\r\n        foreach (var entry in archive.Entries)\r\n        {\r\n            if (excludeFileFilter(entry) || !includeFileFilter(entry))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            using var stream = entry.Open();\r\n            using var reader = new StreamReader(stream);\r\n\r\n            string? line;\r\n            var lineNumber = 0;\r\n\r\n            while ((line = reader.ReadLine()) != null)\r\n            {\r\n                lineNumber\u002B\u002B;\r\n\r\n                if (searchRegex.IsMatch(line))\r\n                {\r\n                    tp.Add(entry.FullName);\r\n\r\n                    if (!string.IsNullOrWhiteSpace(options.ExtractPath))\r\n                    {\r\n                        var sw = Stopwatch.StartNew();\r\n                        entry.ExtractToFile($\u0022{entry.FullName.Replace(\u0027/\u0027, \u0027-\u0027)}\u0022, overwrite: true);\r\n                        Console.WriteLine(\r\n                            $\u0022Time taken to extract {entry.Length} bytes: {sw.Elapsed.TotalMilliseconds} ms.\u0022\r\n                        );\r\n                    }\r\n\r\n                    yield return new(Path.Combine(zipFilePath, entry.FullName), lineNumber, line);\r\n\r\n                    if (options.StopWhenFound)\r\n                    {\r\n                        yield break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\Abstractions\\IDirectoryPacker.cs",
    "content": "namespace Scratchpad.Lib.Abstractions;\r\n\r\npublic interface IDirectoryPacker\r\n{\r\n    Task Pack(\r\n        string basePath,\r\n        string outputFilePath,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n    Task Unpack(\r\n        string textFilePath,\r\n        string outputDirectoryPath,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n}\r\n"
  },
  {
    "path": "Scratchpad.Lib\\Abstractions\\ISecureStorage.cs",
    "content": "using Scratchpad.Lib.Model;\r\n\r\nnamespace Scratchpad.Lib.Abstractions;\r\n\r\npublic interface ISecureStorage\r\n{\r\n    Task SaveCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n    Task\u003CUserCredentials?\u003E GetCredentials(CancellationToken cancellationToken = default);\r\n    void DeleteCredentials();\r\n}\r\n"
  },
  {
    "path": "Scratchpad.ConsoleApp\\IRunner.cs",
    "content": "namespace Scratchpad.ConsoleApp;\r\n\r\ninternal interface IRunner\r\n{\r\n    Task Run(string[] args);\r\n}\r\n"
  },
  {
    "path": "Scratchpad.ConsoleApp\\Program.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing Scratchpad.ConsoleApp;\r\nusing Scratchpad.Lib;\r\n\r\nvar serviceCollection = new ServiceCollection();\r\n\r\nserviceCollection.AddScratchPadLib();\r\nserviceCollection.AddSingleton\u003CIRunner, Runner\u003E();\r\n\r\nusing var serviceProvider = serviceCollection.BuildServiceProvider();\r\n\r\nvar service = serviceProvider.GetRequiredService\u003CIRunner\u003E();\r\n\r\nawait service.Run(args);\r\n"
  },
  {
    "path": "Scratchpad.ConsoleApp\\Runner.cs",
    "content": "using Scratchpad.Lib.Abstractions;\r\n\r\nnamespace Scratchpad.ConsoleApp;\r\n\r\ninternal class Runner : IRunner\r\n{\r\n    private readonly IDirectoryPacker _projectSharer;\r\n\r\n    public Runner(IDirectoryPacker projectSharer)\r\n    {\r\n        _projectSharer = projectSharer;\r\n    }\r\n\r\n    public async Task Run(string[] args)\r\n    {\r\n        await RunProjectSharer();\r\n    }\r\n\r\n    private async Task RunProjectSharer()\r\n    {\r\n        var directoryPathToClone = @\u0022C:\\Users\\user\\projects\\demos\\dotnet-demos\\DotnetScratchpad\u0022;\r\n\r\n        var filePath = Path.Combine(Environment.CurrentDirectory, \u0022importData.json\u0022);\r\n\r\n        if (!Directory.Exists(directoryPathToClone))\r\n        {\r\n            throw new Exception(\u0022Directory does not exist.\u0022);\r\n        }\r\n\r\n        await _projectSharer.Pack(directoryPathToClone, filePath);\r\n\r\n        var outputDirectoryPath =\r\n            @\u0022C:\\Users\\user\\projects\\demos\\dotnet-demos\\DotnetScratchpad-clone\u0022;\r\n\r\n        if (!File.Exists(filePath))\r\n        {\r\n            throw new Exception(\u0022Import file does not exist.\u0022);\r\n        }\r\n\r\n        if (Directory.Exists(outputDirectoryPath))\r\n        {\r\n            throw new Exception(\u0022Directory already exists. Exiting.\u0022);\r\n        }\r\n\r\n        Directory.CreateDirectory(outputDirectoryPath);\r\n\r\n        await _projectSharer.Unpack(filePath, outputDirectoryPath);\r\n    }\r\n}\r\n"
  },
  {
    "path": "Scratchpad.ConsoleApp\\Scratchpad.ConsoleApp.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Efalse\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.DependencyInjection\u0022 Version=\u00229.0.7\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CProjectReference Include=\u0022..\\Scratchpad.Lib\\Scratchpad.Lib.csproj\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "RemoteClipboard\\App.xaml",
    "content": "\u003CApplication\r\n  x:Class=\u0022RemoteClipboard.App\u0022\r\n  xmlns=\u0022http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0022\r\n  xmlns:x=\u0022http://schemas.microsoft.com/winfx/2006/xaml\u0022\r\n  xmlns:local=\u0022clr-namespace:RemoteClipboard\u0022\r\n  Startup=\u0022Application_Startup\u0022\r\n  Exit=\u0022Application_Exit\u0022\r\n  StartupUri=\u0022LoginWindow.xaml\u0022\r\n\u003E\r\n  \u003CApplication.Resources\u003E\u003C/Application.Resources\u003E\r\n\u003C/Application\u003E\r\n"
  },
  {
    "path": "RemoteClipboard\\App.xaml.cs",
    "content": "using System.Windows;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard;\r\n\r\npublic partial class App : Application\r\n{\r\n    private void Application_Startup(object sender, StartupEventArgs e)\r\n    {\r\n        var services = new ServiceCollection();\r\n\r\n        services.AddRemoteClipboard();\r\n\r\n        var serviceProvider = services.BuildServiceProvider(validateScopes: true);\r\n\r\n        DIContainer.SetServiceProvider(serviceProvider);\r\n    }\r\n\r\n    private void Application_Exit(object sender, ExitEventArgs e)\r\n    {\r\n        DIContainer.Dispose();\r\n\r\n        DesktopContext.HotKeyManager.Dispose();\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\AssemblyInfo.cs",
    "content": "using System.Windows;\r\n\r\n[assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)]\r\n"
  },
  {
    "path": "RemoteClipboard\\DIContainer.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\n\r\nnamespace RemoteClipboard;\r\n\r\ninternal static class DIContainer\r\n{\r\n    private static IServiceProvider? _serviceProvider = null;\r\n\r\n    public static T GetRequiredService\u003CT\u003E()\r\n        where T : notnull\r\n    {\r\n        if (_serviceProvider is null)\r\n        {\r\n            throw new Exception();\r\n        }\r\n\r\n        return _serviceProvider.GetRequiredService\u003CT\u003E();\r\n    }\r\n\r\n    public static void SetServiceProvider(IServiceProvider serviceProvider)\r\n    {\r\n        if (_serviceProvider is not null)\r\n        {\r\n            throw new Exception();\r\n        }\r\n\r\n        _serviceProvider = serviceProvider;\r\n    }\r\n\r\n    public static void Dispose()\r\n    {\r\n        ((IDisposable?)_serviceProvider)?.Dispose();\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\DIRegistrations.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\nusing RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Services;\r\n\r\nnamespace RemoteClipboard;\r\n\r\ninternal static class DIRegistrations\r\n{\r\n    public static IServiceCollection AddRemoteClipboard(this IServiceCollection services)\r\n    {\r\n        //services.AddSingleton\u003CIClipboardService, RemoteClipboardService\u003E();\r\n        services.AddSingleton\u003CIClipboardService, LocalTextFileClipboardService\u003E();\r\n        services.AddSingleton\u003CIAuthService, DummyAuthService\u003E();\r\n        services.AddSingleton\u003CIAppService, AppService\u003E();\r\n        services.AddSingleton\u003CISecureStorage, SecureStorage\u003E();\r\n\r\n        return services;\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\LoginWindow.xaml",
    "content": "\u003CWindow\r\n  x:Class=\u0022RemoteClipboard.LoginWindow\u0022\r\n  xmlns=\u0022http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0022\r\n  xmlns:x=\u0022http://schemas.microsoft.com/winfx/2006/xaml\u0022\r\n  xmlns:d=\u0022http://schemas.microsoft.com/expression/blend/2008\u0022\r\n  xmlns:mc=\u0022http://schemas.openxmlformats.org/markup-compatibility/2006\u0022\r\n  xmlns:local=\u0022clr-namespace:RemoteClipboard\u0022\r\n  mc:Ignorable=\u0022d\u0022\r\n  WindowStartupLocation=\u0022CenterScreen\u0022\r\n  Title=\u0022LoginWindow\u0022\r\n  Height=\u0022450\u0022\r\n  Width=\u0022800\u0022\r\n  Loaded=\u0022Window_Loaded\u0022\r\n\u003E\r\n  \u003CGrid\u003E\r\n    \u003CStackPanel VerticalAlignment=\u0022Center\u0022 Margin=\u002220\u0022\u003E\r\n      \u003CTextBlock Text=\u0022Username:\u0022 Margin=\u00220,0,0,5\u0022 /\u003E\r\n      \u003CTextBox x:Name=\u0022UsernameTextBox\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n      \u003CTextBlock Text=\u0022Password:\u0022 Margin=\u00220,0,0,5\u0022 /\u003E\r\n      \u003CPasswordBox x:Name=\u0022PasswordBox\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n      \u003CTextBlock Text=\u0022Clipboard Id:\u0022 Margin=\u00220,0,0,5\u0022 /\u003E\r\n      \u003CTextBox x:Name=\u0022ClipboardIdTextBox\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n      \u003CButton x:Name=\u0022LoginButton\u0022 Content=\u0022Login\u0022 Click=\u0022LoginButton_Click\u0022 Margin=\u00220,10\u0022 /\u003E\r\n      \u003CProgressBar\r\n        x:Name=\u0022LoadingBar\u0022\r\n        Height=\u00222\u0022\r\n        Margin=\u00220,10\u0022\r\n        IsIndeterminate=\u0022True\u0022\r\n        Visibility=\u0022Collapsed\u0022\r\n      /\u003E\r\n      \u003CTextBlock x:Name=\u0022ErrorMessage\u0022 Foreground=\u0022Red\u0022 /\u003E\r\n    \u003C/StackPanel\u003E\r\n  \u003C/Grid\u003E\r\n\u003C/Window\u003E\r\n"
  },
  {
    "path": "RemoteClipboard\\LoginWindow.xaml.cs",
    "content": "using System.Windows;\r\nusing System.Windows.Controls;\r\nusing RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard;\r\n\r\npublic partial class LoginWindow : Window\r\n{\r\n    private readonly IAppService _appService;\r\n\r\n    public LoginWindow()\r\n    {\r\n        InitializeComponent();\r\n\r\n        _appService = DIContainer.GetRequiredService\u003CIAppService\u003E();\r\n    }\r\n\r\n    private async void LoginButton_Click(object sender, RoutedEventArgs e)\r\n    {\r\n        await HandleLogin();\r\n    }\r\n\r\n    private async Task HandleLogin()\r\n    {\r\n        try\r\n        {\r\n            ErrorMessage.Text = string.Empty;\r\n            SetLoadingState(true);\r\n\r\n            var userCredentials = new UserCredentials(\r\n                UsernameTextBox.Text,\r\n                PasswordBox.Password,\r\n                ClipboardIdTextBox.Text\r\n            );\r\n\r\n            if (await _appService.Login(userCredentials))\r\n            {\r\n                var mainWindow = new MainWindow();\r\n                mainWindow.Show();\r\n                Close();\r\n            }\r\n            else\r\n            {\r\n                ErrorMessage.Text = \u0022Invalid username or password\u0022;\r\n                _appService.DeleteSavedCredentials();\r\n            }\r\n        }\r\n        finally\r\n        {\r\n            SetLoadingState(false);\r\n        }\r\n    }\r\n\r\n    private void SetLoadingState(bool isLoading)\r\n    {\r\n        LoginButton.IsEnabled = !isLoading;\r\n        UsernameTextBox.IsEnabled = !isLoading;\r\n        PasswordBox.IsEnabled = !isLoading;\r\n        LoadingBar.Visibility = isLoading ? Visibility.Visible : Visibility.Collapsed;\r\n    }\r\n\r\n    private async void Window_Loaded(object sender, RoutedEventArgs e)\r\n    {\r\n        SetLoadingState(true);\r\n        var savedCredentials = await _appService.GetSavedCredentials();\r\n        SetLoadingState(false);\r\n\r\n        if (savedCredentials == null)\r\n        {\r\n            return;\r\n        }\r\n\r\n        UsernameTextBox.Text = savedCredentials.UserName;\r\n        PasswordBox.Password = savedCredentials.Password;\r\n        ClipboardIdTextBox.Text = savedCredentials.ClipboardId;\r\n\r\n        await HandleLogin();\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\MainWindow.xaml",
    "content": "\u003CWindow\r\n  x:Class=\u0022RemoteClipboard.MainWindow\u0022\r\n  xmlns=\u0022http://schemas.microsoft.com/winfx/2006/xaml/presentation\u0022\r\n  xmlns:x=\u0022http://schemas.microsoft.com/winfx/2006/xaml\u0022\r\n  xmlns:d=\u0022http://schemas.microsoft.com/expression/blend/2008\u0022\r\n  xmlns:mc=\u0022http://schemas.openxmlformats.org/markup-compatibility/2006\u0022\r\n  xmlns:local=\u0022clr-namespace:RemoteClipboard\u0022\r\n  mc:Ignorable=\u0022d\u0022\r\n  WindowStartupLocation=\u0022CenterScreen\u0022\r\n  Loaded=\u0022Window_Loaded\u0022\r\n  Closing=\u0022Window_Closing\u0022\r\n  Title=\u0022MainWindow\u0022\r\n  Height=\u0022450\u0022\r\n  Width=\u0022800\u0022\r\n\u003E\r\n  \u003CGrid\u003E\r\n    \u003CStackPanel Margin=\u002220\u0022\u003E\r\n      \u003CListView\r\n        x:Name=\u0022ClipboardListView\u0022\r\n        Height=\u0022200\u0022\r\n        Margin=\u00220,0,0,10\u0022\r\n        ScrollViewer.HorizontalScrollBarVisibility=\u0022Disabled\u0022\r\n      \u003E\r\n        \u003CListView.ItemTemplate\u003E\r\n          \u003CDataTemplate\u003E\r\n            \u003CGrid Margin=\u00225\u0022\u003E\r\n              \u003CGrid.ColumnDefinitions\u003E\r\n                \u003CColumnDefinition Width=\u0022*\u0022 /\u003E\r\n                \u003CColumnDefinition Width=\u0022Auto\u0022 /\u003E\r\n              \u003C/Grid.ColumnDefinitions\u003E\r\n              \u003CTextBox\r\n                Grid.Column=\u00220\u0022\r\n                Text=\u0022{Binding DisplayText}\u0022\r\n                IsReadOnly=\u0022True\u0022\r\n                BorderThickness=\u00220\u0022\r\n                Background=\u0022Transparent\u0022\r\n                TextWrapping=\u0022NoWrap\u0022\r\n                MaxLength=\u0022100\u0022\r\n                ToolTip=\u0022{Binding Text}\u0022\r\n                Margin=\u00220,0,10,0\u0022\r\n              /\u003E\r\n              \u003CButton\r\n                Grid.Column=\u00221\u0022\r\n                Content=\u0022Copy\u0022\r\n                Width=\u002260\u0022\r\n                Height=\u002225\u0022\r\n                Click=\u0022CopyItemButton_Click\u0022\r\n                Tag=\u0022{Binding Text}\u0022\r\n              /\u003E\r\n            \u003C/Grid\u003E\r\n          \u003C/DataTemplate\u003E\r\n        \u003C/ListView.ItemTemplate\u003E\r\n      \u003C/ListView\u003E\r\n      \u003CButton x:Name=\u0022ReadButton\u0022 Content=\u0022Read\u0022 Click=\u0022ReadButton_Click\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n      \u003CTextBox x:Name=\u0022InputTextBox\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n      \u003CButton x:Name=\u0022WriteButton\u0022 Content=\u0022Write\u0022 Click=\u0022WriteButton_Click\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n      \u003CButton x:Name=\u0022LogoutButton\u0022 Content=\u0022Logout\u0022 Click=\u0022LogoutButton_Click\u0022 Margin=\u00220,0,0,10\u0022 /\u003E\r\n    \u003C/StackPanel\u003E\r\n  \u003C/Grid\u003E\r\n\u003C/Window\u003E\r\n"
  },
  {
    "path": "RemoteClipboard\\MainWindow.xaml.cs",
    "content": "using System.Collections.ObjectModel;\r\nusing System.ComponentModel;\r\nusing System.Windows;\r\nusing System.Windows.Controls;\r\nusing GlobalHotKeys;\r\nusing GlobalHotKeys.Native.Types;\r\nusing RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard;\r\n\r\npublic class ClipboardItem\r\n{\r\n    public string Text { get; set; }\r\n    public string DisplayText { get; set; }\r\n\r\n    public ClipboardItem(string text)\r\n    {\r\n        Text = text;\r\n        DisplayText = text.Length \u003E 100 ? text[..100] \u002B \u0022...\u0022 : text;\r\n    }\r\n}\r\n\r\npublic partial class MainWindow : Window\r\n{\r\n    private readonly IClipboardService _clipboardService;\r\n    private readonly IAppService _appService;\r\n    private readonly SemaphoreSlim _semaphoreSlim = new(1, 1);\r\n    private readonly ObservableCollection\u003CClipboardItem\u003E _clipboardItems = [];\r\n\r\n    IRegistration? hotkeyManagerCtrlShiftCRegistration;\r\n    IRegistration? hotkeyManagerCtrlShiftDelRegistration;\r\n    IDisposable? hotKeyPressedEventSubscription;\r\n\r\n    public MainWindow()\r\n    {\r\n        InitializeComponent();\r\n\r\n        _clipboardService = DIContainer.GetRequiredService\u003CIClipboardService\u003E();\r\n        _appService = DIContainer.GetRequiredService\u003CIAppService\u003E();\r\n\r\n        ClipboardListView.ItemsSource = _clipboardItems;\r\n    }\r\n\r\n    private void Window_Loaded(object sender, RoutedEventArgs e)\r\n    {\r\n        hotkeyManagerCtrlShiftCRegistration = DesktopContext.HotKeyManager.Register(\r\n            VirtualKeyCode.KEY_C,\r\n            Modifiers.Control | Modifiers.Shift | Modifiers.NoRepeat\r\n        );\r\n\r\n        hotkeyManagerCtrlShiftDelRegistration = DesktopContext.HotKeyManager.Register(\r\n            VirtualKeyCode.VK_BACK,\r\n            Modifiers.Control | Modifiers.Shift | Modifiers.NoRepeat\r\n        );\r\n\r\n        hotKeyPressedEventSubscription = DesktopContext.HotKeyManager.HotKeyPressed.Subscribe(\r\n            async hotKey =\u003E\r\n            {\r\n                if (!await _semaphoreSlim.WaitAsync(0))\r\n                {\r\n                    return;\r\n                }\r\n\r\n                if (hotKey.Key == VirtualKeyCode.KEY_C)\r\n                {\r\n                    await Dispatcher.InvokeAsync(async () =\u003E\r\n                    {\r\n                        try\r\n                        {\r\n                            await HandleRead();\r\n                        }\r\n                        finally\r\n                        {\r\n                            _semaphoreSlim.Release();\r\n                        }\r\n                    });\r\n                }\r\n                else if (hotKey.Key == VirtualKeyCode.VK_BACK)\r\n                {\r\n                    await Dispatcher.InvokeAsync(async () =\u003E\r\n                    {\r\n                        try\r\n                        {\r\n                            await Task.Delay(1000);\r\n                            MessageBox.Show(\u0022HALLOOOO\u0022);\r\n                        }\r\n                        finally\r\n                        {\r\n                            _semaphoreSlim.Release();\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    private void Window_Closing(object sender, CancelEventArgs e)\r\n    {\r\n        hotkeyManagerCtrlShiftCRegistration?.Dispose();\r\n        hotkeyManagerCtrlShiftDelRegistration?.Dispose();\r\n\r\n        hotKeyPressedEventSubscription?.Dispose();\r\n    }\r\n\r\n    private async void ReadButton_Click(object sender, RoutedEventArgs e)\r\n    {\r\n        await HandleRead();\r\n    }\r\n\r\n    private async void WriteButton_Click(object sender, RoutedEventArgs e)\r\n    {\r\n        await HandleWrite();\r\n    }\r\n\r\n    private void CopyItemButton_Click(object sender, RoutedEventArgs e)\r\n    {\r\n        if (sender is Button button \u0026\u0026 button.Tag is string text)\r\n        {\r\n            _appService.SetClipboardText(text);\r\n        }\r\n    }\r\n\r\n    private void LogoutButton_Click(object sender, RoutedEventArgs e)\r\n    {\r\n        HandleLogout();\r\n    }\r\n\r\n    private void HandleLogout()\r\n    {\r\n        _appService.Logout();\r\n        var loginWindow = new LoginWindow();\r\n        loginWindow.Show();\r\n        Close();\r\n    }\r\n\r\n    private async Task HandleWrite()\r\n    {\r\n        SetLoading(true);\r\n\r\n        var text = !string.IsNullOrWhiteSpace(InputTextBox.Text) ? InputTextBox.Text : null;\r\n\r\n        text ??= _appService.GetClipboardText();\r\n\r\n        await _clipboardService.WriteToClipboard(text);\r\n\r\n        SetLoading(false);\r\n    }\r\n\r\n    private async Task HandleRead()\r\n    {\r\n        SetLoading(true);\r\n\r\n        var result = await _clipboardService.ReadLastNEntriesFromClipboard(5);\r\n\r\n        if (result.Count \u003E 0)\r\n        {\r\n            _clipboardItems.Clear();\r\n\r\n            foreach (var item in result)\r\n            {\r\n                _clipboardItems.Add(new ClipboardItem(item));\r\n            }\r\n\r\n            _appService.SetClipboardText(result[0]);\r\n        }\r\n\r\n        SetLoading(false);\r\n    }\r\n\r\n    private void SetLoading(bool isLoading)\r\n    {\r\n        WriteButton.IsEnabled = !isLoading;\r\n        ReadButton.IsEnabled = !isLoading;\r\n        LogoutButton.IsEnabled = !isLoading;\r\n        ClipboardListView.IsEnabled = !isLoading;\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\RemoteClipboard.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EWinExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet8.0-windows\u003C/TargetFramework\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CUseWPF\u003Etrue\u003C/UseWPF\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022GlobalHotKeys.Windows\u0022 Version=\u00220.1.0\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.DependencyInjection\u0022 Version=\u00229.0.7\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "RemoteClipboard\\Services\\AppService.cs",
    "content": "using System.Windows;\r\nusing RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Services;\r\n\r\ninternal sealed class AppService : IAppService\r\n{\r\n    private readonly IAuthService _authService;\r\n    private readonly ISecureStorage _secureStorage;\r\n\r\n    public AppService(IAuthService authService, ISecureStorage secureStorage)\r\n    {\r\n        _authService = authService;\r\n        _secureStorage = secureStorage;\r\n    }\r\n\r\n    public async Task\u003Cbool\u003E Login(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        await _authService.ValidateCredentials(userCredentials, cancellationToken);\r\n\r\n        DesktopContext.UserCredentials = userCredentials;\r\n\r\n        await _secureStorage.SaveCredentials(userCredentials, cancellationToken);\r\n\r\n        return true;\r\n    }\r\n\r\n    public void Logout()\r\n    {\r\n        DesktopContext.UserCredentials = null;\r\n\r\n        _secureStorage.DeleteCredentials();\r\n    }\r\n\r\n    public string GetClipboardText()\r\n    {\r\n        try\r\n        {\r\n            return Clipboard.GetText(TextDataFormat.UnicodeText);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex);\r\n            return string.Empty;\r\n        }\r\n    }\r\n\r\n    public void SetClipboardText(string text)\r\n    {\r\n        try\r\n        {\r\n            Clipboard.SetText(text, TextDataFormat.UnicodeText);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex);\r\n        }\r\n    }\r\n\r\n    public async Task\u003CUserCredentials?\u003E GetSavedCredentials(\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        return await _secureStorage.GetCredentials(cancellationToken);\r\n    }\r\n\r\n    public void DeleteSavedCredentials()\r\n    {\r\n        _secureStorage.DeleteCredentials();\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Services\\DummyAuthService.cs",
    "content": "using RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Services;\r\n\r\ninternal sealed class DummyAuthService : IAuthService\r\n{\r\n    private static TimeSpan Jitter =\u003E TimeSpan.FromMilliseconds(new Random().Next(200, 2000));\r\n\r\n    public async Task ValidateCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        await Task.Delay(Jitter, cancellationToken);\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Services\\LocalTextFileClipboardService.cs",
    "content": "using System.IO;\r\nusing RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Services;\r\n\r\ninternal class LocalTextFileClipboardService : IClipboardService\r\n{\r\n    private static string DirectoryBasePath =\u003E\r\n        Path.Combine(Environment.CurrentDirectory, DesktopContext.UserCredentials!.ClipboardId);\r\n\r\n    private static TimeSpan Jitter =\u003E TimeSpan.FromMilliseconds(new Random().Next(200, 2000));\r\n\r\n    public async Task WriteToClipboard(\r\n        string? text = null,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        await Task.Delay(Jitter, cancellationToken);\r\n\r\n        Directory.CreateDirectory(DirectoryBasePath);\r\n\r\n        var fileName = $\u0022{Guid.NewGuid()}.txt\u0022;\r\n        await File.WriteAllTextAsync(\r\n            Path.Combine(DirectoryBasePath, fileName),\r\n            text,\r\n            cancellationToken\r\n        );\r\n    }\r\n\r\n    public async Task\u003Cstring\u003E ReadFromClipboard(CancellationToken cancellationToken = default)\r\n    {\r\n        await Task.Delay(Jitter, cancellationToken);\r\n        var fileName = GetLastNFiles(1).FirstOrDefault();\r\n\r\n        if (fileName is null)\r\n        {\r\n            return string.Empty;\r\n        }\r\n\r\n        return await File.ReadAllTextAsync(fileName, cancellationToken);\r\n    }\r\n\r\n    public async Task\u003CList\u003Cstring\u003E\u003E ReadLastNEntriesFromClipboard(\r\n        int n,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        await Task.Delay(Jitter, cancellationToken);\r\n        var filePathlist = GetLastNFiles(n);\r\n        List\u003Cstring\u003E result = [];\r\n\r\n        foreach (var item in filePathlist)\r\n        {\r\n            result.Add(await File.ReadAllTextAsync(item, cancellationToken));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private static List\u003Cstring\u003E GetLastNFiles(int n)\r\n    {\r\n        Directory.CreateDirectory(DirectoryBasePath);\r\n        return Directory\r\n            .EnumerateFiles(DirectoryBasePath)\r\n            .OrderByDescending(File.GetLastWriteTime)\r\n            .Take(n)\r\n            .ToList();\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Services\\RemoteClipboardService.cs",
    "content": "using System.Net.Http;\r\nusing System.Net.Http.Headers;\r\nusing System.Net.Http.Json;\r\nusing System.Text;\r\nusing RemoteClipboard.Abstractions;\r\n\r\nnamespace RemoteClipboard.Services;\r\n\r\ninternal class RemoteClipboardService : IClipboardService\r\n{\r\n    private static readonly SocketsHttpHandler httpHandler = new()\r\n    {\r\n        PooledConnectionLifetime = TimeSpan.FromMinutes(5),\r\n        PooledConnectionIdleTimeout = TimeSpan.FromMinutes(2),\r\n        SslOptions = new() { RemoteCertificateValidationCallback = (_, _, _, _) =\u003E true },\r\n    };\r\n\r\n    private static string? _lastKvp;\r\n    private static AuthenticationHeaderValue _authenticationHeader = null!;\r\n\r\n    public async Task\u003Cstring\u003E ReadFromClipboard(CancellationToken cancellationToken = default)\r\n    {\r\n        using var httpClient = GetHttpClient();\r\n\r\n        var response = await httpClient.GetAsync(\u0022/123\u0022, cancellationToken);\r\n\r\n        return await response.Content.ReadAsStringAsync(cancellationToken);\r\n    }\r\n\r\n    public async Task WriteToClipboard(string text, CancellationToken cancellationToken = default)\r\n    {\r\n        using var httpClient = GetHttpClient();\r\n\r\n        var response = await httpClient.PostAsJsonAsync(\u0022/123\u0022, new object(), cancellationToken);\r\n    }\r\n\r\n    private static AuthenticationHeaderValue GetAuthenticationHeaderValue()\r\n    {\r\n        var userName = \u0022\u0022;\r\n        var password = \u0022\u0022;\r\n        var kvp = $\u0022{userName}:{password}\u0022;\r\n\r\n        if (_lastKvp == kvp)\r\n        {\r\n            return _authenticationHeader;\r\n        }\r\n\r\n        _lastKvp = kvp;\r\n        _authenticationHeader = new(\r\n            \u0022Basic\u0022,\r\n            Convert.ToBase64String(Encoding.UTF8.GetBytes(_lastKvp))\r\n        );\r\n\r\n        return _authenticationHeader;\r\n    }\r\n\r\n    private static HttpClient GetHttpClient()\r\n    {\r\n        var httpClient = new HttpClient(httpHandler, disposeHandler: false)\r\n        {\r\n            BaseAddress = new Uri(\u0022http://localhost:5173\u0022),\r\n        };\r\n\r\n        httpClient.DefaultRequestHeaders.Authorization = GetAuthenticationHeaderValue();\r\n\r\n        return httpClient;\r\n    }\r\n\r\n    public Task\u003CList\u003Cstring\u003E\u003E ReadLastNEntriesFromClipboard(\r\n        int n,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Services\\SecureStorage.cs",
    "content": "using System.IO;\r\nusing System.Security.Cryptography;\r\nusing System.Text;\r\nusing System.Text.Json;\r\nusing RemoteClipboard.Abstractions;\r\nusing RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Services;\r\n\r\npublic class SecureStorage : ISecureStorage\r\n{\r\n    private static string GetFilePath =\u003E\r\n        Path.Combine(Environment.CurrentDirectory, \u0022encryptedcredentials.dat\u0022);\r\n\r\n    public async Task SaveCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        try\r\n        {\r\n            var json = JsonSerializer.Serialize(userCredentials);\r\n            var dataToEncrypt = Encoding.UTF8.GetBytes(json);\r\n            var encryptedData = ProtectedData.Protect(\r\n                dataToEncrypt,\r\n                null,\r\n                DataProtectionScope.CurrentUser\r\n            );\r\n\r\n            await File.WriteAllBytesAsync(GetFilePath, encryptedData, cancellationToken);\r\n        }\r\n        catch { }\r\n    }\r\n\r\n    public async Task\u003CUserCredentials?\u003E GetCredentials(\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        try\r\n        {\r\n            var encryptedData = await File.ReadAllBytesAsync(GetFilePath, cancellationToken);\r\n            var decryptedData = ProtectedData.Unprotect(\r\n                encryptedData,\r\n                null,\r\n                DataProtectionScope.CurrentUser\r\n            );\r\n\r\n            var json = Encoding.UTF8.GetString(decryptedData);\r\n\r\n            return JsonSerializer.Deserialize\u003CUserCredentials\u003E(json);\r\n        }\r\n        catch\r\n        {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public void DeleteCredentials()\r\n    {\r\n        try\r\n        {\r\n            File.Delete(GetFilePath);\r\n        }\r\n        catch { }\r\n    }\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Model\\DesktopContext.cs",
    "content": "using GlobalHotKeys;\r\n\r\nnamespace RemoteClipboard.Model;\r\n\r\npublic static class DesktopContext\r\n{\r\n    public static UserCredentials? UserCredentials { get; set; }\r\n    public static HotKeyManager HotKeyManager { get; } = new();\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Model\\UserCredentials.cs",
    "content": "namespace RemoteClipboard.Model;\r\n\r\npublic record UserCredentials(string UserName, string Password, string ClipboardId);\r\n"
  },
  {
    "path": "RemoteClipboard\\Abstractions\\IAppService.cs",
    "content": "using RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Abstractions;\r\n\r\ninternal interface IAppService\r\n{\r\n    Task\u003Cbool\u003E Login(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n\r\n    void Logout();\r\n\r\n    string GetClipboardText();\r\n\r\n    void SetClipboardText(string text);\r\n\r\n    Task\u003CUserCredentials?\u003E GetSavedCredentials(CancellationToken cancellationToken = default);\r\n    void DeleteSavedCredentials();\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Abstractions\\IAuthService.cs",
    "content": "using RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Abstractions;\r\n\r\npublic interface IAuthService\r\n{\r\n    Task ValidateCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Abstractions\\IClipboardService.cs",
    "content": "namespace RemoteClipboard.Abstractions;\r\n\r\npublic interface IClipboardService\r\n{\r\n    Task WriteToClipboard(string text, CancellationToken cancellationToken = default);\r\n    Task\u003Cstring\u003E ReadFromClipboard(CancellationToken cancellationToken = default);\r\n    Task\u003CList\u003Cstring\u003E\u003E ReadLastNEntriesFromClipboard(\r\n        int n,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n}\r\n"
  },
  {
    "path": "RemoteClipboard\\Abstractions\\ISecureStorage.cs",
    "content": "using RemoteClipboard.Model;\r\n\r\nnamespace RemoteClipboard.Abstractions;\r\n\r\ninternal interface ISecureStorage\r\n{\r\n    Task SaveCredentials(\r\n        UserCredentials userCredentials,\r\n        CancellationToken cancellationToken = default\r\n    );\r\n\r\n    Task\u003CUserCredentials?\u003E GetCredentials(CancellationToken cancellationToken = default);\r\n\r\n    void DeleteCredentials();\r\n}\r\n"
  },
  {
    "path": "ProjectPacker\\Program.cs",
    "content": "using System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\n\r\nnamespace ProjectPacker;\r\n\r\n[JsonSourceGenerationOptions(\r\n    WriteIndented = true,\r\n    IndentSize = 2,\r\n    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase\r\n)]\r\n//[JsonSerializable(typeof(FileData))]\r\n[JsonSerializable(typeof(List\u003CFileData\u003E))]\r\npublic partial class AppJsonSerializerContext : JsonSerializerContext { }\r\n\r\npublic record FileData(string Path, string Content);\r\n\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            if (\r\n                args.ElementAtOrDefault(0) == \u0022pack\u0022\r\n                \u0026\u0026 args.ElementAtOrDefault(1) is not null\r\n                \u0026\u0026 args.ElementAtOrDefault(2) is not null\r\n            )\r\n            {\r\n                if (!Directory.Exists(args[1]))\r\n                {\r\n                    throw new Exception($\u0022Directory {args[1]} does not exist.\u0022);\r\n                }\r\n\r\n                await Pack(args[1], args[2]);\r\n                return;\r\n            }\r\n\r\n            if (\r\n                args.ElementAtOrDefault(0) == \u0022unpack\u0022\r\n                \u0026\u0026 args.ElementAtOrDefault(1) is not null\r\n                \u0026\u0026 args.ElementAtOrDefault(2) is not null\r\n            )\r\n            {\r\n                if (!File.Exists(args[1]))\r\n                {\r\n                    throw new Exception(\u0022Import file does not exist.\u0022);\r\n                }\r\n\r\n                if (Directory.Exists(args[2]))\r\n                {\r\n                    throw new Exception($\u0022Directory {args[2]} already exists.\u0022);\r\n                }\r\n\r\n                Directory.CreateDirectory(args[2]);\r\n\r\n                await Unpack(args[1], args[2]);\r\n                return;\r\n            }\r\n\r\n            ShowHelpAndExit();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine($\u0022An error occurred: {ex.Message}\\n{ex.StackTrace}\u0022);\r\n        }\r\n    }\r\n\r\n    private static void ShowHelpAndExit()\r\n    {\r\n        var executableName = Path.GetFileNameWithoutExtension(Environment.ProcessPath);\r\n        Console.WriteLine(\r\n            $\u0022\u0022\u0022\r\n            Usage:\r\n                {executableName} pack \u003Cpath/to/project/directory\u003E \u003CoutputMetadataFileName\u003E\r\n                {executableName} unpack \u003Cpath/to/metadata/file\u003E \u003Cpath/to/output/directory\u003E\r\n            \u0022\u0022\u0022\r\n        );\r\n        Environment.Exit(1);\r\n    }\r\n\r\n    private static async Task Pack(\r\n        string basePath,\r\n        string outputFilePath,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        List\u003CFileData\u003E importData = [];\r\n\r\n        foreach (\r\n            var filePath in EnumerateFiles(\r\n                basePath,\r\n                IncludeFiles,\r\n                IgnoreDirectories,\r\n                cancellationToken: cancellationToken\r\n            )\r\n        )\r\n        {\r\n            importData.Add(\r\n                new FileData(\r\n                    Path.GetRelativePath(basePath, filePath),\r\n                    await File.ReadAllTextAsync(filePath, cancellationToken)\r\n                )\r\n            );\r\n        }\r\n\r\n        await File.WriteAllTextAsync(\r\n            outputFilePath,\r\n            JsonSerializer.Serialize(importData, AppJsonSerializerContext.Default.ListFileData),\r\n            cancellationToken\r\n        );\r\n    }\r\n\r\n    private static async Task Unpack(\r\n        string importFilePath,\r\n        string outputDirectoryPath,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        var importFileContent = await File.ReadAllTextAsync(importFilePath, cancellationToken);\r\n        var importData =\r\n            JsonSerializer.Deserialize(\r\n                importFileContent,\r\n                AppJsonSerializerContext.Default.ListFileData\r\n            ) ?? throw new Exception(\u0022Import data not found or not valid json.\u0022);\r\n\r\n        foreach (var fileData in importData)\r\n        {\r\n            var filePath = Path.Combine(outputDirectoryPath, fileData.Path);\r\n\r\n            var dirPath = Path.GetDirectoryName(filePath)!;\r\n\r\n            if (!Directory.Exists(dirPath))\r\n            {\r\n                Directory.CreateDirectory(dirPath);\r\n            }\r\n\r\n            await File.WriteAllTextAsync(filePath, fileData.Content, cancellationToken);\r\n        }\r\n    }\r\n\r\n    private static bool IncludeFiles(string path)\r\n    {\r\n        var ext = Path.GetExtension(path);\r\n\r\n        return ext == \u0022.cs\u0022\r\n            || ext == \u0022.csproj\u0022\r\n            || ext == \u0022.sln\u0022\r\n            || ext == \u0022.editorconfig\u0022\r\n            || ext == \u0022.xaml\u0022\r\n            || ext == \u0022.vsct\u0022\r\n            || ext == \u0022.vsixmanifest\u0022;\r\n    }\r\n\r\n    private static bool IgnoreDirectories(string path)\r\n    {\r\n        return path.Contains(\u0022bin\u0022) || path.Contains(\u0022obj\u0022);\r\n    }\r\n\r\n    private static IEnumerable\u003Cstring\u003E EnumerateFiles(\r\n        string rootPath,\r\n        Func\u003Cstring, bool\u003E? includeFilePredicate = null,\r\n        Func\u003Cstring, bool\u003E? ignoreDirPredicate = null,\r\n        EnumerationOptions? enumerationOptions = null,\r\n        CancellationToken cancellationToken = default\r\n    )\r\n    {\r\n        if (!Directory.Exists(rootPath))\r\n        {\r\n            throw new DirectoryNotFoundException($\u0022Directory not found: {rootPath}\u0022);\r\n        }\r\n\r\n        includeFilePredicate ??= _ =\u003E true;\r\n        ignoreDirPredicate ??= _ =\u003E false;\r\n\r\n        enumerationOptions ??= new EnumerationOptions { IgnoreInaccessible = true };\r\n\r\n        var directoryStack = new Stack\u003Cstring\u003E();\r\n        directoryStack.Push(rootPath);\r\n\r\n        while (directoryStack.Count \u003E 0)\r\n        {\r\n            cancellationToken.ThrowIfCancellationRequested();\r\n            var currentPath = directoryStack.Pop();\r\n\r\n            foreach (var filePath in Directory.EnumerateFiles(currentPath, \u0022*\u0022, enumerationOptions))\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n                if (includeFilePredicate(filePath))\r\n                {\r\n                    yield return filePath;\r\n                }\r\n            }\r\n\r\n            foreach (\r\n                var dirPath in Directory.EnumerateDirectories(currentPath, \u0022*\u0022, enumerationOptions)\r\n            )\r\n            {\r\n                cancellationToken.ThrowIfCancellationRequested();\r\n                if (!ignoreDirPredicate(dirPath))\r\n                {\r\n                    directoryStack.Push(dirPath);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
  },
  {
    "path": "ProjectPacker\\ProjectPacker.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Etrue\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "LogSearch\\LogSearch.ConsoleApp\\LogSearch.ConsoleApp.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Etrue\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n    \u003C!-- Uncomment below to use local project references instead of nuget packages --\u003E\r\n    \u003C!--\u003CUseLocalProjectReferences\u003Etrue\u003C/UseLocalProjectReferences\u003E--\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.DependencyInjection\u0022 Version=\u00229.0.7\u0022 /\u003E\r\n    \u003CPackageReference Include=\u0022FuzzySharp\u0022 Version=\u00222.0.2\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup Condition=\u0022$(UseLocalProjectReferences) != true\u0022\u003E\r\n    \u003CPackageReference Include=\u0022Vaerktojer.Prompt\u0022 Version=\u00220.0.1\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n  \u003CItemGroup Condition=\u0022$(UseLocalProjectReferences) == true\u0022\u003E\r\n    \u003CProjectReference Include=\u0022..\\..\\..\\..\\..\\Vaerktojer.Prompt\\Vaerktojer.Prompt\\Vaerktojer.Prompt.csproj\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "LogSearch\\LogSearch.ConsoleApp\\Model.cs",
    "content": "namespace LogSearch.ConsoleApp;\r\n\r\npublic sealed record ServiceInfo\r\n{\r\n    public required string ServiceName { get; set; }\r\n    public required string LogPath { get; set; }\r\n    public required string Identifier { get; set; }\r\n    public required List\u003Cstring\u003E Servers { get; set; }\r\n    public required string LogSearchPattern { get; set; }\r\n}\r\n"
  },
  {
    "path": "LogSearch\\LogSearch.ConsoleApp\\Program.cs",
    "content": "using LogSearch.ConsoleApp;\r\nusing Microsoft.Extensions.DependencyInjection;\r\n\r\nvar services = new ServiceCollection();\r\n\r\nservices.AddSingleton\u003CService\u003E();\r\n\r\nvar serviceProvider = services.BuildServiceProvider(validateScopes: true);\r\n\r\nvar service = serviceProvider.GetRequiredService\u003CService\u003E();\r\n\r\nservice.Run();\r\n"
  },
  {
    "path": "LogSearch\\LogSearch.ConsoleApp\\Service.cs",
    "content": "using System.ComponentModel.DataAnnotations;\r\nusing FuzzySharp;\r\nusing Vaerktojer.Prompt;\r\n\r\nnamespace LogSearch.ConsoleApp;\r\n\r\ninternal sealed class Service\r\n{\r\n    private readonly List\u003CFunc\u003Cobject?, ValidationResult?\u003E\u003E regularValidators =\r\n    [\r\n        value =\u003E\r\n        {\r\n            if (string.IsNullOrWhiteSpace(value?.ToString()))\r\n            {\r\n                return new ValidationResult(\u0022Username must not be empty\u0022);\r\n            }\r\n\r\n            return null;\r\n        },\r\n    ];\r\n\r\n    public void Run()\r\n    {\r\n        var (userName, password) = Login();\r\n\r\n        var data = Load(userName, password);\r\n\r\n        var applicationName = Prompt.Select(\r\n            \u0022Select application to search\u0022,\r\n            data.Keys,\r\n            pageSize: 2,\r\n            textInputFilter: SearchFilter\r\n        );\r\n\r\n        var servers = Prompt.MultiSelect(\r\n            \u0022Select servers to search\u0022,\r\n            data[applicationName].Servers,\r\n            pageSize: 2,\r\n            textInputFilter: SearchFilter\r\n        );\r\n\r\n        var (startDate, endDate) = GetDates();\r\n\r\n        // Search here...\r\n\r\n        Console.WriteLine(\u0022Found files\u0022);\r\n\r\n        var foundFiles = new List\u003C(string FilePath, DateTime LastModifiedDate)\u003E(\r\n            Enumerable\r\n                .Range(1, 5)\r\n                .Select(x =\u003E\r\n                    (\r\n                        $@\u0022C:\\users\\user\\desktop\\demos\\hello{x}.log\u0022,\r\n                        DateTime.Now.Subtract(TimeSpan.FromMinutes(x))\r\n                    )\r\n                )\r\n        );\r\n\r\n        var z = foundFiles.Select(x =\u003E x.FilePath).ToList();\r\n\r\n        var selectedFoundFiles = Prompt.MultiSelect(\r\n            \u0022Select files to open\u0022,\r\n            z,\r\n            textInputFilter: SearchFilter\r\n        );\r\n\r\n        foreach (var foundFile in selectedFoundFiles)\r\n        {\r\n            // OpenWithNpp(foundFile)\r\n        }\r\n    }\r\n\r\n    private (string Username, string Password) Login()\r\n    {\r\n        while (true)\r\n        {\r\n            var username = Prompt.Input\u003Cstring\u003E(\u0022Username\u0022, validators: regularValidators);\r\n            var password = Prompt.Password(\u0022Password\u0022, validators: regularValidators);\r\n\r\n            if (username == \u0022admin\u0022)\r\n            {\r\n                Console.WriteLine(\u0022Logged in as admin.\u0022);\r\n                return (username, password);\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\u0022Invalid credentials.\u0022);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static (DateTime StartDate, DateTime EndDate) GetDates()\r\n    {\r\n        var searchIntervalChoice = Prompt.Select(\r\n            \u0022Select search interval\u0022,\r\n            [\r\n                15,\r\n                60,\r\n                60 * 2,\r\n                60 * 3,\r\n                60 * 6,\r\n                60 * 12,\r\n                60 * 24,\r\n                60 * 24 * 2,\r\n                60 * 24 * 5,\r\n                60 * 24 * 7,\r\n                -1,\r\n            ],\r\n            textSelector: value =\u003E\r\n            {\r\n                return value switch\r\n                {\r\n                    \u003C= 0 =\u003E \u0022Custom\u0022,\r\n                    \u003C 60 =\u003E $\u0022Last {value} minutes\u0022,\r\n                    \u003E= 60 * 24 * 7 =\u003E $\u0022Last {value / (60 * 24)} weeks\u0022,\r\n                    \u003E= 60 * 24 =\u003E $\u0022Last {value / (60 * 24)} days\u0022,\r\n                    \u003E= 60 =\u003E $\u0022Last {value / 60} hours\u0022,\r\n                };\r\n            },\r\n            searchIsEnabled: false\r\n        );\r\n\r\n        if (searchIntervalChoice != -1)\r\n        {\r\n            return (\r\n                DateTime.Now.Subtract(TimeSpan.FromMinutes(searchIntervalChoice)),\r\n                DateTime.Now.Subtract(TimeSpan.FromMinutes(1))\r\n            );\r\n        }\r\n\r\n        var startDate = Prompt.Input\u003CDateTime\u003E(\r\n            \u0022Enter start date\u0022,\r\n            placeholder: \u0022YYYY-MM-dd HH:mm:ss format\u0022,\r\n            defaultValue: DateTime.Now.Subtract(TimeSpan.FromMinutes(5)),\r\n            validators:\r\n            [\r\n                value =\u003E\r\n                {\r\n                    if (value is not DateTime date)\r\n                    {\r\n                        return new ValidationResult($\u0022{value} is not a valid value for DateTime.\u0022);\r\n                    }\r\n\r\n                    if (date \u003E DateTime.Now)\r\n                    {\r\n                        return new ValidationResult(\u0022Start date must be less than or equal to now\u0022);\r\n                    }\r\n\r\n                    if (date \u003C DateTime.Now.Subtract(TimeSpan.FromDays(365 * 5)))\r\n                    {\r\n                        return new ValidationResult(\u0022Start date must be bigger than 5 years ago\u0022);\r\n                    }\r\n\r\n                    return null;\r\n                },\r\n            ]\r\n        );\r\n\r\n        var endDate = Prompt.Input\u003CDateTime\u003E(\r\n            \u0022Enter end date\u0022,\r\n            placeholder: \u0022YYYY-MM-dd HH:mm:ss format\u0022,\r\n            validators:\r\n            [\r\n                value =\u003E\r\n                {\r\n                    if (value as DateTime? == DateTime.MinValue)\r\n                    {\r\n                        return new ValidationResult(\u0022Value is required\u0022);\r\n                    }\r\n\r\n                    if (value as DateTime? \u003C= startDate)\r\n                    {\r\n                        return new ValidationResult(\u0022End date must be bigger than start date\u0022);\r\n                    }\r\n\r\n                    return null;\r\n                },\r\n            ]\r\n        );\r\n\r\n        return (startDate, endDate);\r\n    }\r\n\r\n    private static bool SearchFilter(string item, string keyword)\r\n    {\r\n        return keyword.Length \u003C 10\r\n            ? item.Contains(keyword, StringComparison.OrdinalIgnoreCase)\r\n            : Fuzz.Ratio(item.ToUpperInvariant(), keyword.ToUpperInvariant()) \u003E 60;\r\n    }\r\n\r\n    private static Dictionary\u003Cstring, ServiceInfo\u003E Load(string userName, string password)\r\n    {\r\n        Dictionary\u003Cstring, ServiceInfo\u003E v = [];\r\n\r\n        foreach (var line in File.ReadAllLines(\u0022data.txt\u0022))\r\n        {\r\n            var spl = line.Split(\u0027,\u0027);\r\n\r\n            List\u003Cstring\u003E b = [];\r\n            foreach (var item in spl[3].Split(\u0027;\u0027))\r\n            {\r\n                var sp = item.Split(\u0027-\u0027);\r\n                var first = sp[0];\r\n                var num = sp.ElementAtOrDefault(1);\r\n\r\n                if (num is null)\r\n                {\r\n                    b.Add(first);\r\n                    continue;\r\n                }\r\n\r\n                var num1 = int.Parse(num);\r\n\r\n                for (int i = 1; i \u003C num1; i\u002B\u002B)\r\n                {\r\n                    b.Add($\u0022{first}{i}\u0022);\r\n                }\r\n            }\r\n\r\n            var a = new ServiceInfo\r\n            {\r\n                ServiceName = spl[0],\r\n                LogPath = spl[1],\r\n                Identifier = spl[2],\r\n                Servers = b,\r\n                LogSearchPattern = spl[4],\r\n            };\r\n\r\n            v[a.ServiceName] = a;\r\n        }\r\n\r\n        return v;\r\n    }\r\n}\r\n"
  },
  {
    "path": "LogGrep\\AppCommands.cs",
    "content": "using System.ComponentModel.DataAnnotations;\r\nusing ConsoleAppFramework;\r\n\r\nnamespace LogGrep;\r\n\r\npublic sealed class AppCommands\r\n{\r\n    [Command(\u0022\u0022)]\r\n    public async Task Hello([EmailAddress] [Argument] string emailAddress, [Path] string path)\r\n    {\r\n        await Task.Delay(100);\r\n        Console.WriteLine(emailAddress);\r\n    }\r\n}\r\n\r\ninternal class MyFilter(ConsoleAppFilter next) : ConsoleAppFilter(next)\r\n{\r\n    public override Task InvokeAsync(ConsoleAppContext context, CancellationToken cancellationToken)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n\r\npublic class PathAttribute : ValidationAttribute\r\n{\r\n    public override bool IsValid(object? value)\r\n    {\r\n        var path = value?.ToString();\r\n        if (string.IsNullOrWhiteSpace(path))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return Path.IsPathFullyQualified(path) \u0026\u0026 File.Exists(path);\r\n    }\r\n\r\n    //public override string FormatErrorMessage(string name)\r\n    //{\r\n    //    return $\u0022Wowzer {name}\u0022;\r\n    //}\r\n}\r\n"
  },
  {
    "path": "LogGrep\\DIRegistrations.cs",
    "content": "using Microsoft.Extensions.DependencyInjection;\r\n\r\nnamespace LogGrep;\r\n\r\npublic static class DIRegistrations\r\n{\r\n    public static IServiceCollection AddLogGrep(this IServiceCollection services)\r\n    {\r\n        //services.AddSingleton\u003CProgram\u003E();\r\n        return services;\r\n    }\r\n}\r\n"
  },
  {
    "path": "LogGrep\\LogGrep.csproj",
    "content": "\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet9.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n    \u003CPublishAot\u003Etrue\u003C/PublishAot\u003E\r\n    \u003CInvariantGlobalization\u003Etrue\u003C/InvariantGlobalization\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022ConsoleAppFramework\u0022 Version=\u00225.5.0\u0022\u003E\r\n      \u003CIncludeAssets\u003Eruntime; build; native; contentfiles; analyzers; buildtransitive\u003C/IncludeAssets\u003E\r\n      \u003CPrivateAssets\u003Eall\u003C/PrivateAssets\u003E\r\n    \u003C/PackageReference\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.Extensions.DependencyInjection\u0022 Version=\u00229.0.7\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n"
  },
  {
    "path": "LogGrep\\Program.cs",
    "content": "using ConsoleAppFramework;\r\nusing LogGrep;\r\n\r\nvar app = ConsoleApp\r\n    .Create()\r\n    .ConfigureServices(x =\u003E\r\n    {\r\n        x.AddLogGrep();\r\n    });\r\n\r\napp.Add\u003CAppCommands\u003E();\r\napp.UseFilter\u003CMyFilter\u003E();\r\n\r\napp.Run(args);\r\n"
  }
]